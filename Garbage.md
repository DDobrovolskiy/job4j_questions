## Garbage Collection

[1. Чем java отличается от с++?](#1-Чем-java-отличается-от-с)

[2. Что такое менеджер памяти?](#2-Что-такое-менеджер-памяти)

[3. Какой механизм используется в Java для управления памятью?](#3-Какой-механизм-используется-в-Java-для-управления-памятью)

[4. Опишите процесс работы сборщика мусора?](#4-Опишите-процесс-работы-сборщика-мусора)

[5. Какие алгоритмы сборщика вы знаете?](#5-Какие-алгоритмы-сборщика-вы-знаете)

[6. Чем отличаются сборщики мусора?](#6-Чем-отличаются-сборщики-мусора)

[7. Расскажите про утилиты для анализа памяти?](#7-Расскажите-про-утилиты-для-анализа-памяти)

[8. Что такое ссылки?](#8-Что-такое-ссылки)

[9. Какие типы ссылок вы знаете?](#9-Какие-типы-ссылок-вы-знаете)

[10. Чем они отличаются?](#10-Чем-они-отличаются)

## 1. Чем java отличается от с++?

В C++ выделение и освобождение памяти - это ручной процесс (например, с помощью операторов `new` и `delete`). 

В Java процесс освобождения памяти автоматически обрабатывается сборщиком мусора. 
(освобождает память в куче, занятой неиспользуемыми объектами)

Т.е. в отличие от С++ нет явной необходимости уничтожать объект. 

[к оглавлению](#garbage-collection)

## 2. Что такое менеджер памяти?

**Менеджер памяти** — часть компьютерной программы (как прикладной, так и операционной системы), 
обрабатывающая запросы на выделение и освобождение оперативной памяти 
или (для некоторых архитектур ЭВМ) запросы на включение заданной области памяти в адресное пространство процессора.

Основное назначение менеджера памяти в первом смысле — реализация динамической памяти, т.е. 
выделение оперативной памяти компьютера для объектов в программе осуществляется во время ее выполнения.

Менеджеры памяти часто образуют иерархию, т.е. нижестоящие менеджеры задействуют какие-либо закономерности выделения-освобождения 
памяти и этим снижают нагрузку на вышестоящие. Например:

+ Системный - менеджер памяти, встроенный в ОС.
+ Принадлежащий процессу - менеджер памяти, встроенный в стандартную библиотеку языка программирования, 
берёт у ОС блоки памяти «оптом» и раздаёт их сообразно с нуждами программиста.
+ Специализированные - некоторые динамические структуры данных, например, `vector`, 
также берут память у стандартной библиотеки с запасом (обычно, блоками экспоненциально увеличивающегося размера). 

Подобная иерархия приводит к тому, что на каждом из уровней «залёживается» свободная память. 
Но это оправдано: снижается фрагментация памяти и повышается скорость.

[к оглавлению](#garbage-collection)

## 3. Какой механизм используется в Java для управления памятью?

Распределение памяти в java реализует технология Java HotSpot от Oracle. 
Она обеспечивает динамическое выделение памяти для объектов и сборщиков мусора.

Память процесса делится на non-heap (до JDK 8 stack) и heap (куча):

В предыдущих выпусках Java Hotspot VM метаданные класса выделялись в Permanent Generation.
Начиная с JDK 8, permanent generation было удалено, а метаданные класса размещены в собственной памяти. 
Объем собственной памяти, которую можно использовать для метаданных класса, по умолчанию не ограничен. 

+ Stack (структура non-heap до JDK 8)
    + Permanent Generation — содержит необходимые для управления программой метаданные классов, 
    в том числе метаданные о созданных объектах, методах и т.п.
    + Code Cache — используемая JVM память при включенной JIT-компиляции 
    (в этой области памяти кешируется скомпилированный платформенно-зависимый код)     
 
+ Heap - куча (тут и работает GC)
    + New (Yang) Generation - хранит короткоживущие объекты.
        + Eden Space — сюда аллоцируются среднестатистические объекты*. Если нет места запускается малая сборка мусора (minor GC). 
        + Survivor Space — точнее их два, S1 и S2, и они меняются ролями. 
        Хранятся перемещенные из Eden Space объекты, признанные живыми во время сборки мусора (без разницы малой или полной). 
        Объекты, пережившие несколько сборок мусора, перемещаются в следующую сборку Tenured Generation.
    + Old (Tenured) Generation - хранит долгоживущие объекты. Когда данная область памяти заполняется, 
    выполняется полная сборка мусора (full GC).

Алгоритм GC исходит из того предположения, что большинство java-объектов живут недолго. 
Быстро становятся мусором. От них необходимо довольно оперативно избавляться. Что и происходит в New Generation. 
Там сбор мусора гораздо чаще, чем в Old Generation, где хранятся долгоживущие объекты. 
После создания объект попадает в New Generation и имеет шанс попасть в Old Generation по прошествии нескольких циклов GC.

*объекты-акселераты, размер которых настолько велик, что создавать их в Eden, 
а потом таскать за собой по Survivor’ам слишком накладно, размещаются сразу в Tenured Generation.

[к оглавлению](#garbage-collection)

## 4. Опишите процесс работы сборщика мусора?

Сборщик мусора (Garbage Collector) - часть JVM, который призван очищать память, выделенную приложению. 
GC выполняет 2 задачи:

1. находит мусор (неиспользуемые объекты)
2. удаляет мусор

Для обнаружения мусора существует два подхода :

+ Reference counting (учет ссылок) - у каждого объекта есть счетчик указывающих на него ссылок, 
при уничтожении ссылки счетчик уменьшается. Когда он равен нулю, объект считается мусором. 

Главный недостатком - сложность обеспечения точности счетчика и «невозможность» выявлять циклические зависимости. 
Например, два объекта могут ссылаться друг на друга, но ни на один из них нет внешней ссылки. 
Это сопровождается утечками памяти. В этой связи данный подход не получил распространения.

+ Tracing (трассировка) - объект считается не мусором, если до него можно добраться с корневых точек(GC Root), 
а всё, что доступно из «живого» объекта, также является «живым». 
Если представить все объекты и ссылки между ними как дерево, то необходимо пройти от корневых узлов GC Roots по всем 
узлам. При этом узлы, до которых нельзя добраться, являются мусором.

Трассировка используется в виртуальной машине HotSpot VM.

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_4.1.png)

Типы корневых точек (GC Root):

+ Основной Java поток.
+ Локальные переменные в основном методе.
+ Статические переменные основного класса.

Таким образом, простое java-приложение будет иметь следующие корневые точки:

+ Параметры `main`-метода и локальные переменные внутри `main`-метода.
+ Поток, который выполняет `main`.
+ Статические переменные основного класса, внутри которого находится `main`-метод.

Имеется два подхода к очистке памяти, которые в совокупности определяют принцип функционирования Garbage Collection.

1. *Copying collectors* - в чистом виде в HotSpot VM не используется.

    Область памяти делится на две части: в одной части размещаются объекты, а вторая часть остается чистой. 
    На время очистки мусора приложение останавливает работу и запускается `GC`, который находит в первой области 
    объекты со ссылками и переносит их во вторую (чистую) область. После этого, первая область очищается от оставшихся 
    там объектов без ссылок, и области меняются местами.

    Достоинство данного подхода - плотное заполнение памяти. 
    
    Недостаток - необходимость остановки приложения и размеры двух частей памяти должны быть одинаковыми на случай, 
    когда все объекты остаются «живыми».

2. *Mark-and-sweep* - также в чистом виде в HotSpot VM не используется.

    Все объекты размещаются в одном сегменте памяти. Сборка мусора также приостанавливает приложение, и GC проходит 
    по дереву объектов, помечая занятые ими области памяти, как «живые». После этого, все не помеченные участки памяти 
    сохраняются в «free list», в которой будут, после завершения сборки мусора, размещаться новые объекты.
    
    Недостатки - необходимость приостановки приложения. 
    Кроме этого, время сборки мусора, как и время приостановки приложения, зависит от размера памяти. 
    Память становится «решетчатой», и, если не применить «уплотнение», то память будет использоваться неэффективно.

Различные сборщики мусора используют разные подходы к организации памяти и ее очистке, 
но их объединяет общая черта — все они опираются на слабую гипотезу о поколениях.
В общем виде, гипотеза о поколениях гласит, что вероятность смерти как функция от возраста снижается очень быстро. 
Ее приложение к сборке мусора означает, что подавляющее большинство объектов живут крайне недолго.

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_4.2.png)

Вот тут и возникает идея разделения объектов на младшее поколение (young generation) и старшее поколение (old generation). 
В соответствии с этим разделением и процессы сборки мусора разделяются на малую сборку (minor GC), затрагивающую только 
младшее поколение, и полную сборку (full GC), которая может затрагивать оба поколения. 

При этом разделение объектов по поколениям не просто условное, они физически размещаются в разных регионах памяти. 
Объекты из младшего поколения по мере выживания в сборках мусора переходят в старшее поколение. В старшем поколении 
объект может прожить до окончания работы приложения, либо будет удален в процессе одной из полных сборок мусора.

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_4.3.png)

Малые сборки выполняются, когда объем свободной памяти в области Eden Space становится критичным.
В этом случае, Garbage Collector просто переносит объекты, имеющие ссылки, из области Eden Space в область 
Survivor Space, а объекты без ссылок удаляет. 
Малые сборки выполняются быстро, довольно часто и удаляют основную часть мертвых объектов. 

Полные сборки выполняются, когда памяти в области Survivor Space недостаточно. При этом долгоживущие объекты переносятся 
в область Tenured Generation, где они могут хранится до конца работы приложения. Вся остальная куча очищается от мусора.

Следует отметить, что сборщик мусора периодически вызывается виртуальной машиной, а не только тогда, 
когда не хватает памяти.

При определении эффективности работы сборщика мусора учитываются следующие факторы:

+ Максимальная задержка — максимальное время, на которое сборщик приостанавливает выполнение программы для выполнения 
одной сборки. Такие остановки называются stop-the-world (или STW).
+ Пропускная способность — отношение общего времени работы программы к общему времени простоя, 
вызванного сборкой мусора, на длительном промежутке времени.
+ Потребляемые ресурсы — объем ресурсов процессора и/или дополнительной памяти, потребляемых сборщиком.

Добиться улучшения всех трех параметров одновременно практически невозможно. Уменьшение максимального времени задержки 
приводит к учащению сборки мусора, уменьшая пропускную способность. Либо приходится использовать более ухищренные 
алгоритмы для сохранения пропускной способности, что чаще всего увеличивает потребление ресурсов.

Поэтому при настройке сборщиков мусора разработчики обычно фокусируются на оптимизации одного или двух параметров, 
стараясь сильно не ухудшать остальные, но жертвуя ими в случае необходимости.

[к оглавлению](#garbage-collection)

## 5. Какие алгоритмы сборщика вы знаете?

Виды сборщиков:

+ **Serial GC**
+ **Parallel GC**
+ **Concurrent Mark Sweep (CMS)**
+ **Garbage-First (G1)**
+ **Z Garbage Collector (ZGC)**

**Serial** 

Когда нет места в Eden, запускается GC, живые объекты коприруются в S1. Вся область Eden очищается. 
S1 и S2 меняются местами. При последующих циклах в S1 будут записаны живые объекты как из Eden, так и из S2. 
После нескольких циклов обмена S1 и S2 или заполнения области S2, обекты, 
которые живут достаточно долго перемещаются в Old Generation.

Следует сказать, что не всегда объекты при создании аллоцируюся в Eden. 
Если объект слишком велик, он сразу идет в Old Generation.

Когда после очередной сборки мусора места нехватает уже в New Generation, то запускается сбор мусора в Old Generation 
(наряду со сборкой в New Generation). В Old Generation объекты уплотняются (алгоритм Mark-Sweep-Compact).

Если после полной сборки мусора места нехватает, то вылетает `Java.lang.OutOfMemoryError`.

Но во время работы VM может запрашивать увеличение памяти и Heap может увеличиваться.

Как правило, Old Generation занимает 2/3 объема Heap.

Эффективоность алгоритма сборки мусора считается по параметру STW (Stop The World) - время, когда все процессы кроме 
GC останавливаются. Serial в этом смысле не слишком эффективен, т.к. делает свою работу не торопясь, в одном потоке.

**Parallel** 

То же, что и Serial, но использует для работы несколько потоков. Таким образом STW чуть меньше.

**Concurrent Mark Sweep** 

Принцип работы с New Generation такой же, как и в случае алгоритмов Serial и Parallel, отличия в том, 
что данный алгоритм разделяет младшую (New Generation) и старшую (Old Generation) сборку мусора во времени. 
Причем сбор мусора в Old Generation происходит в отдельном потоке, независимо от младшей сборки. 
При этом сначала приложение останавливается, сборщик помечает все живые объекты доступные из GC Root (корневых точек) 
напрямую, затем приложение вновь начинает работу, а сбощик проверяет объекты доступные по ссылкам из этих самых 
помеченных, и также помечает их как живые. Эта особенность создает так называемые плавающие объекты, которые помечены 
как живые, но таковыми по факту не являющимися. Но они будут удалены в следующих циклах. 
Т.е. пропускная способность растет, STW уменьшается, но требутся больше места для хранения плавающих объектов.

В этом алгоритме уплотнения нет. Т.е. область Old Generation дефрагментированна.

**Garbage-First** 

G1 сильно отличается от своих предшественников. Он делит область Heap не физически, а скорее логически на те же области: 
Eden, Survivor, Old Generation. Причем дефрагментированно. Физически область Heap делится на регионы одинакового 
размера, каждый из которых может быть Eden, Survivor или Old Generation + область для больших объектов (громадный регион).

Над очисткой регионов Eden работает сразу несколько потоков, объекты переносятся в регионы Survivor или регионы 
старшего поколения (Tenured). Это знакомый по предыдущим алгоритмам очистки подход. 
На время очистки работа приложения останавливается. Отличие в том, что очистка производится не по всем регионам Eden, 
а только по некоторым, которые более всего в ней нуждаются, таким образом регулируется время очистки. 
Отсюда название алгоритма - в первую очередь мусор.

А с полной сборкой (точнее, здесь она называется смешанной (mixed)) все немного хитроумнее, чем в рассмотренных 
ранее сборщиках. В G1 существует процесс, называемый циклом пометки (marking cycle), который работает параллельно с 
основным приложением и составляет список живых объектов. За исключением последнего пункта, этот процесс выглядит уже 
знакомо для нас:

+ `Initial mark`. Пометка корней (с остановкой основного приложения) с использованием информации, полученной из малых сборок.
+ `Concurrent marking`. Пометка всех живых объектов в куче в нескольких потоках, параллельно с работой основного приложения.
+ `Remark`. Дополнительный поиск не учтенных ранее живых объектов (с остановкой основного приложения).
+ `Cleanup`. Очистка вспомогательных структур учета ссылок на объекты и поиск пустых регионов, которые уже можно 
использовать для размещения новых объектов. Первая часть этого шага выполняется при остановленном основном приложении.
После окончания цикла пометки G1 переключается на выполнение смешанных сборок. Это значит, что при каждой сборке к 
набору регионов младшего поколения, подлежащих очистке, добавляется некоторое количество регионов старшего поколения. 
Количество таких сборок и количество очищаемых регионов старшего поколения выбирается исходя из имеющейся у 
сборщика статистики о предыдущих сборках таким образом, чтобы не выходить за требуемое время сборки. 
Как только сборщик очистил достаточно памяти, он переключается обратно в режим малых сборок.

Очередной цикл пометки и, как следствие, очередные смешанные сборки будут запущены тогда, 
когда заполненность кучи превысит определенный порог.

Опираясь на уже упомянутую статистику о предыдущих сборках, G1 может менять количество регионов, 
закрепленных за определенным поколением, для оптимизации будущих сборок.

Громадные регионы. С точки зрения JVM объекты которые превышают размер половины региона являются громадными. Особенности:

+ никогда не перемещается между регионами
+ может удаляться в рамках цикла пометки или полной сборки мусора
+ в регионе, занятом громадным объектом, может находится только он сам.

Громадные объекты в силу небольшого размера регионов могут порождать проблемы с точки зрения STW.

G1 выигрывает по времени STW, но расплатой является меньшая пропускная способность 
(около 90%, ср., например у Parallel ок. 99%) т.е. большие затраты ресурсов процессора.

**Z Garbage Collector (ZGC)**

ZGC - это масштабируемый сборщик мусора с малой задержкой, выполняет всю дорогостоящую работу одновременно, 
не останавливая выполнение потоков приложения.

ZGC предназначен для приложений, которые требуют малой задержки (паузы менее 10 мс) и/или используют очень большую кучу 
(мульти-терабайты). Включается с помощью опции `-XX:+UseZGC`.

ZGC доступен в качестве экспериментальной функции, начиная с JDK 11.

[к оглавлению](#garbage-collection)

## 6. Чем отличаются сборщики мусора?

**Serial (последовательный)** — самый простой вариант для приложений, 
которым не требуется большой размер кучи для работы (Oracle указывает условную границу 100 МБ), 
которые не очень чувствительны к коротким остановкам и им для работы доступно только одно ядро процессора.
Редко когда используется, но на слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию.

**+** Непритязательность по части ресурсов компьютера. Т.к. всю работу он выполняет последовательно в одном потоке, никаких заметных оверхедов и негативных побочных эффектов у него нет.

**-** Долгие паузы на сборку мусора при заметных объемах данных. 

**-** Все настройки Serial GC крутятся вокруг размеров различных регионов кучи, т.е. для тонкой настройки 
требуется вручную что-то изучать, настраивать, экспериментировать и т.д. 

**Parallel (параллельный)** — наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в 
некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности.
В целом, Parallel GC — это простой, понятный и эффективный сборщик, подходящий для большинства приложений. 
У него нет скрытых накладных расходов, мы всегда можем поменять его настройки и ясно увидеть результат этих изменений.

**+** в сравнении с Serial GC есть возможность автоматической подстройки под требуемые параметры производительности 
и меньшие паузы на время сборок. При наличии нескольких процессорных ядер выигрыш в скорости будет практически во всех приложениях.

**-** Определенная фрагментация памяти, но вряд ли она будет существенной для большинства приложений, 
т.к. сборщиком используется относительно небольшое количество потоков.

**Concurrent Mark Sweep (CMS)** — нацелен на снижение максимальных задержек путем выполнения части работ по сборке мусора 
параллельно с основными потоками приложения. Более требователен к ресурсам процессора.
Подходит для работы в приложениях с относительно большими объемами долгоживущих данных,
для приложений, имеющих доступ к нескольким ядрам процессора и чувствительных к паузам STW.

**+** по сравнению с рассмотренными ранее Serial/Parallel GC ориентирован на минимизацию времени простоя, 
что является критическим фактором для многих приложений. 
Но для выполнения этой задачи приходится жертвовать ресурсами процессора и зачастую общей пропускной способностью.

**-** не уплотняет объекты в старшем поколении, что приводит к фрагментации области Tenured. 
Этот факт в совокупности с наличием плавающего мусора приводит к необходимости выделять приложению 
(конкретно — старшему поколению) больше памяти, чем потребовалось бы для других сборщиков (Oracle советует на 20% больше).

**-** долгие паузы при потенциально возможных сбоях конкурентного режима могут стать неприятным сюрпризом. 
Хотя они не частые, и при наличии достаточного объема памяти сборщику CMS удается их полностью избегать.

**Garbage-First (G1)** — создан для замены CMS, но не является явным продолжением линейки Serial/Parallel/CMS. 
Мспользуется в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных 
(размер кучи от 4 ГБ и выше), для которых важно сохранять время отклика небольшим и предсказуемым, пусть даже за счет 
уменьшения пропускной способности.

**+** G1 более точно предсказывает размеры пауз, чем CMS, и лучше распределяет сборки во времени, 
чтобы не допустить длительных остановок приложения, особенно при больших размерах кучи. 

**+** В отличие от CMS, например, он не фрагментирует память.

**-** Тратит ресурсы процессора, которые использует для выполнения достаточно большой части своей работы параллельно с основной программой. 
В результате страдает пропускная способность приложения. 
Целевое значением пропускной способности по умолчанию для G1 равно 90%, для Parallel GC составляет 99%. 
Это не значит, что пропускная способность с G1 всегда будет почти на 10% меньше, но данную особенность следует учитывать.

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_6.1.png)
 
«Монолитный» означает то, что всё поколение должно быть очищено за проход.

«В большинстве случаев одновременный» — mostly concurrent, одновременный имеется в виду фоновый, «работающий вместе с потоками приложения».

**Z Garbage Collector (ZGC)** - это масштабируемый сборщик мусора с малой задержкой. 
ZGC выполняет всю дорогостоящую работу одновременно, не останавливая выполнение потоков приложения.

ZGC предназначен для приложений, которые требуют малой задержки (паузы менее 10 мс) и/или используют очень большую кучу 
(мульти-терабайты). Включается с помощью опции `-XX:+UseZGC`.

ZGC доступен в качестве экспериментальной функции, начиная с JDK 11.

Подробнее здесь https://habr.com/ru/post/269621/

[к оглавлению](#garbage-collection)

## 7. Расскажите про утилиты для анализа памяти?

встроенные в JDK утилиты: jps, jmap, jstat, jconsole, visualvm до java 9.

внешние: VisualVM c java 9 и утилита от NetBeans - YourKit Java Profiler.

jconsole, visualvm и yourkit profiler предоставляют удобный визуальный интерфейс.

**jps** - выводит pid-ы процессов, которые использует VM

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.1.png)

 
**jmap** - выводит информацию о состоянии памяти виртуальной машины
	
`jmap -heap 14152` или `jhsdb jmap --heap --pid 14152`
	
![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.2.png)
 
**jstat** - аналогично jmap

**jstack** - показывает какие процессы запущены в  виртуальной машине (нет инфы о памяти)

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.3.png)
 
...

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.4.png) 

**jconsole**
 
![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.5.png) 

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.6.png)

**VisualVM** (с плагином VisualGC)

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/gc_7.7.png) 

**YourKit Profiler** - универсальный расширенный профилировщик, используется не только для анализа памяти, 
но и ,например, для поиска узких мест в коде (повторения и тп)

[к оглавлению](#garbage-collection)

## 8. Что такое ссылки?

Ссылки в Java — это указатели на объекты. Другими словами, ссылка — это переменная, содержащая адрес ячейки памяти, 
в которой хранится объект. Кроме того, ссылка может быть инициализирована как `null` — нулевая ссылка, не указывающая 
ни на какой объект в памяти (именно это значение является значением по умолчанию). Внутри класса в нестатическом 
контексте также может быть использована ссылка `this`, указывающая на текущий объект, и ссылка `super`, 
указывающая на текущий объект суперкласса.

Абстрактный класс `java.lang.ref.Reference` предоставляет базу для ссылочных классов. В нём определены следующие методы:

+ `get` — метод, возвращающий сильную ссылку на объект, на который указывает ссылка.
+ `clear` — очищает ссылку.
+ `isEnqueued` и `enqueue`, отвечающие за взаимодействие ссылки и объекта `ReferenceQueue`.

[к оглавлению](#garbage-collection)

## 9. Какие типы ссылок вы знаете?

В Java существует четыре типа ссылок, различающихся по способу сбора мусора и 
предоставляющие пользователю возможность более гибко работать с памятью:
                                                                            
+ **Сильные ссылки (Strong References)** - стандартные ссылки, создаются каждый раз, когда аллоцируем место в памяти через 
оператор new. Если на объект есть хоть одна жесткая ссылка, то данный объект не будет утилизирован при сборке мусора.

```java
Counter counter = new Counter(); // strong reference
```

+ **Слабые ссылки (WeakReferences)** - создаются с помощью вызова `new WeakReference<T>(T obj, ReferenceQueue<T> queue)` или 
`new WeakReference<T>(T obj)`. Если на объект есть только слабая ссылка, то будет выполнена попытка утилизации данного 
объекта при сборке мусора.

```java
Counter counter = new Counter(); // strong reference - line 1
WeakReference<Counter> weakCounter = new WeakReference<Counter>(counter); //weak reference
counter = null; // now Counter object is eligible for garbage collection
```

+ **Мягкие ссылки (Soft References)** - создаются с помощью вызова `new SoftReference<T>(T obj, ReferenceQueue<T> queue)` или 
`new SoftReference(T obj)`. Если на объект есть только мягкая ссылка, то будет выполнена попытка утилизации данного 
объекта при сборке мусора в случае, если приложению не хватает памяти.

```java
Counter prime = new Counter();  // prime holds a strong reference - line 2
SoftReference<Counter> soft = new SoftReference<Counter>(prime) ; //soft reference variable has SoftReference to Counter Object created at line 2

prime = null;  // now Counter object is eligible for garbage collection but only be collected when JVM absolutely needs memory
```

+ **Фантомные ссылки (PhantomReferences)** - создаются с помощью вызова `new PhantomReference<T>(T obj, ReferenceQueue<T> queue)`. 
Если на объект есть только фантомная ссылка, то будет выполнена попытка утилизации данного объекта при сборке мусора. 
Сам объект при этом не будет удален из памяти до тех пор, пока на него существует фантомная ссылка или данная 
фантомная ссылка не очищена с помощью вызова метода `clear()`. Так же стоит заметить, что метод `get()` фантомной ссылки 
всегда возвращает `null`.

```java
DigitalCounter digit = new DigitalCounter(); // digit reference variable has strong reference - line 3
PhantomReference<DigitalCounter> phantom = new PhantomReference<DigitalCounter>(digit); // phantom reference to object created at line 3

digit = null;
```

[к оглавлению](#garbage-collection)

## 10. Чем они отличаются?

Сначала общее правило: политика зачистки для некоего объекта и очистки ссылок на него определяется самыми жёсткими из 
всех ссылок, что на него указывают.

Различие между всеми типами ссылок только одно — поведение GC с объектами, на которые они ссылаются:

+ **StrongReference** нужны для указания на объекты, которые должны обязательно оставаться в памяти всё то время, 
что эти ссылки на него существуют. Объект будет уничтожен только в том случае, если мы явно назначим ссылке `null`, 
либо потеряем доступ к ссылке через класс родитель (например класс родитель обнулится и объект также обнулиться. 
Обнулится, т.е. его будет обрабатывать GC и высвобождать память из этого объекта)

+ **WeakReference** — если GC видит что объект доступен только через цепочку weak-ссылок, то он удалит его из памяти.

Пример использования: `WeakHashMap` - это реализация которая хранит ключ, используя weak-ссылку. 
Когда сильная ссылка на фактический объект удалена и затем GC удаляет ключ из памяти, то удаляется вся запись из Map: 
при добавлении новой пары <ключ, значение>, создается WeakReference для ключа и в конструктор передается ReferenceQueue. 
Когда GC удаляет ключ с памяти, то ReferenceQueue возвращает соответствующий WeakReference для этого ключа. 
После этого соответствующий Entry удаляется с Map. 

`WeakHashMap` не предназначена для использования в качестве кэша. WeakReference создается для ключа, а не для значения. 
И данные будут удалены только после того, как в программе не останется strong-ссылок на ключ, а не на значение. 
В большинстве случаев это не то, чего вы хотите достичь кэшированием.
Данные с `WeakHashMap` будут удалены не сразу после того как GC обнаружит, что ключ доступен только через weak-ссылки. 
Фактически очистка произойдет при следующем обращении к `WeakHashMap`.
В первую очередь `WeakHashMap` предназначен для использования с ключами, у которых метод `equals` проверяет идентичность 
объектов (использует оператор `==`). Как только доступ к ключу потерян, его уже нельзя создать заново.

+ **SoftReference** — если GC видит что объект доступен только через цепочку soft-ссылок, то он удалит его из памяти 
только в случае необходимости. По сути SoftReference - это механизм кэширования объектов в памяти, но в критической 
ситуации, когда закончится доступная память, GC удалит не использующиеся объекты из памяти и тем самым попробует 
спасти JVM от завершения работы.

Общий контракт звучит следующим образом: GC гарантировано удалит из кучи все объекты, доступные только по soft-ссылке, 
перед тем как бросит `OutOfMemoryError`. 

Например, если нужно насоздавать ещё объектов с сильными ссылками, а уже негде, лучше освободить кэш и 
замедлить работу, чем уронить процесс напрочь.

*Основная разница между SoftReference и WeakReference, в том, что SoftReference являются более подходящим для кэшей, а 
WeakReference для хранения метаданных.*

+ **PhantomReference** — если GC видит что объект доступен только через цепочку phantom-ссылок, то он его удалит из памяти, 
когда это ему "понравится" (зависит от реализации GC, возможно после нескольких запусков)

[к оглавлению](#garbage-collection)

## Источники:

**Сравнение языков программирования** 

https://ru.wikipedia.org/wiki/%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%8F%D0%B7%D1%8B%D0%BA%D0%BE%D0%B2_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F

**Описание распределения памяти в JVM, принципы работы и виды GC** 

HotSpot Virtual Machine Garbage Collection Tuning Guide https://docs.oracle.com/en/java/javase/12/gctuning/index.html

"Сборщик мусора Garbage Collection" http://java-online.ru/garbage-collection.xhtml

"Дюк, вынеси мусор! — Часть 1" https://habr.com/ru/post/269621/

"How Garbage Collection works in Java" https://javarevisited.blogspot.com/2011/04/garbage-collection-in-java.html

"Краткий конспект реализации Garbage Collector в Java" https://ziginsider.github.io/Garbage_Collector_Java/

"Секреты сборки мусора в Java" http://profyclub.ru/docs/305

"Сборщик мусора G1 в Java 9" https://urvanov.ru/2018/03/25/%d1%81%d0%b1%d0%be%d1%80%d1%89%d0%b8%d0%ba-%d0%bc%d1%83%d1%81%d0%be%d1%80%d0%b0-g1-%d0%b2-java-9/

**Типы ссылок в Java** 

"Ссылка (Java)" http://cyclowiki.org/wiki/%D0%A1%D1%81%D1%8B%D0%BB%D0%BA%D0%B0_(Java)#targetText=%D0%A1%D1%81%D1%8B%D0%BB%D0%BA%D0%B8%20%D0%B2%20Java%20%E2%80%94%20%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8%20%D0%BD%D0%B0,%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%8F%D0%B2%D0%BB%D1%8F%D0%B5%D1%82%D1%81%D1%8F%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC%20%D0%BF%D0%BE%20%D1%83%D0%BC%D0%BE%D0%BB%D1%87%D0%B0%D0%BD%D0%B8%D1%8E).

"Difference between WeakReference vs SoftReference vs PhantomReference vs Strong reference in Java" https://javarevisited.blogspot.com/2014/03/difference-between-weakreference-vs-softreference-phantom-strong-reference-java.html

"Types of References in Java" https://www.geeksforgeeks.org/types-references-java/

"Мягкие ссылки на страже доступной памяти или как экономить память правильно" https://habr.com/ru/post/169883/

"Weak, Soft, and Phantom References in Java (and Why They Matter)" https://dzone.com/articles/weak-soft-and-phantom-references-in-java-and-why-they-matter

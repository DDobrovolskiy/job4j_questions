### 1. Что такое сервлет?
Сервлет представляет специальный тип классов Java, который выполняется на веб-сервере и который обрабатывает запросы и возвращает результат обработки.

### 2. Какова структура веб-проекта?
```xml
  ├── pom.xml  
  └── src  
    ├── main  
      │   ├── java  
      │   │   └── mygroup  
      │   │       ├── controller  
      │   │       │   ├── HomeController.java  
      │   │       │   └── PersonController.java  
      │   │       ├── dao  
      │   │       │   └── PersonDao.java  
      │   │       └── model  
      │   │           └── Person.java  
      │   ├── resources  
      │   │   ├── db.properties  
      │   │   ├── log4j.xml  
      │   │   └── META-INF  
      │   │       └── persistence.xml  
      │   └── webapp  
      │       ├── index.html  
      │       ├── META-INF  
      │       │   ├── context.xml  
      │       │   └── MANIFEST.MF  
      │       ├── resources  
      │       │   └── css  
      │       │       └── screen.css  
      │       └── WEB-INF  
      │           ├── spring  
      │           │   ├── app  
      │           │   │   ├── controllers.xml  
      │           │   │   └── servlet-context.xml  
      │           │   ├── db.xml  
      │           │   └── root-context.xml  
      │           ├── views  
      │           │   ├── edit.jsp  
      │           │   ├── home.jsp  
      │           │   └── list.jsp  
      │           └── web.xml  
      └── test  
          ├── java  
          │   └── mygroup  
          │       ├── controller  
          │       │   ├── DataInitializer.java  
          │       │   ├── HomeControllerTest.java  
          │       │   └── PersonControllerTest.java  
          │       └── dao  
          │           └── PersonDaoTest.java  
          └── resources  
              ├── db.properties  
              ├── log4j.xml  
              ├── test-context.xml  
              └── test-db.xml  
```

### 3. Что такое контейнер сервлетов?
Контейнер сервлетов — программа, представляющая собой сервер, который занимается системной поддержкой сервлетов и обеспечивает их жизненный цикл в соответствии с правилами, определёнными в спецификациях.

### 4. Каковы задачи, функциональность контейнера сервлетов?
Контейнер сервлетов может работать как полноценный самостоятельный веб-сервер, быть поставщиком страниц для другого веб-сервера, например Apache, или интегрироваться в Java EE сервер приложений. Обеспечивает обмен данными между сервлетом и клиентами, берёт на себя выполнение таких функций, как создание программной среды для функционирующего сервлета, идентификацию и авторизацию клиентов, организацию сессии для каждого из них.

### 5. Что вы знаете о сервлет фильтрах?
Сервлет-фильтр используется для контроля запроса и ответа клиента на сервлет или для изменения запроса и ответа, а также для аудита и регистрации.

### 6. Зачем нужны слушатели в сервлетах?
Слушатель сервлета используется для прослушивания событий в веб-контейнерах, например, при создании сеанса или размещения атрибута в сеансе или при пассиве и активации в другом контейнере для подписки на эти события

### 7. Когда вы будете использовать фильтры сервлетов, а когда слушатели?
Следует использовать фильтры, если необходимо обрабатывать входящие или исходящие данные (например: для аутентификации, преобразования формата, компрессии, шифрования и т.д.), в случае, когда необходимо реагировать на события - лучше применять слушателей.

### 8. Как обработать исключения, выброшенные другим сервлетом в приложении?
Когда приложение выбрасывет исключение контейнер сервлетов обрабатывает его и создаёт ответ в формате HTML.
(т.е. контейнер создаст HTTP response, т.к. браузер понимает только HTTP)
Это аналогично тому что происходит при кодах ошибок вроде 404, 403 и т.д.

В дополнении к этому существует возможность написания собственных сервлетов для обработки исключений и ошибок 
с указанием их в дескрипторе развертывания:

```xml
<error-page>
    <error-code>404</error-code>
    <location>/AppExceptionHandler</location>
</error-page>
<error-page>
    <exception-type>javax.servlet.ServletException</exception-type>
    <location>/AppExceptionHandler</location>
</error-page>
```

Основная задача таких сервлетов - обработать ошибку/исключение и сформировать понятный HTTP ответ пользователю. 
Например, предоставить ссылку на главную страницу или же описание некоторых деталей об ошибке.

http://www.journaldev.com/1973/servlet-exception-and-error-handling-example-tutorial

### 9. Что такое дескриптор развертывания?
Дескриптор развертывания веб-приложений описывает классы, ресурсы и конфигурацию приложения, а так же как сервер будет использовать их для выполнения веб-запросов. Когда сервер получает запрос для приложения, он использует дескриптор развертывания для отображения URL запроса к коду, который должен этот запрос обработать.

### 10. Как реализовать запуск сервлета с запуском приложения?

Контейнер сервлетов обычно загружает сервлет по первому запросу клиента.

Если необходимо загрузить сервлет прямо на старте приложения (например если загрузка сервлета происходит длительное время) 
следует использовать элемент `<load-on-startup>` в дескрипторе или аннотацию `@loadOnStartup` в коде сервлета, 
что будет указывать на необходимость загрузки сервлета при запуске.

Значение должно быть целочисленное `int`. Если значение отрицательное, то сервлет будет загружен при запросе клиента. 
В противном случае (0 и далее) - загрузится на старте приложения. 
Чем число меньше, тем раньше в очереди на загрузку окажется сервлет.

```xml
<servlet>
    <servlet-name>ExampleServlet</servlet-name>
    <servlet-class>xyz.company.ExampleServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
</servlet>
```

### 11. Что представляет собой объект ServletConfig?
Интерфейс `javax.servlet.ServletConfig` используется для передачи сервлету конфигурационной информации. 
Каждый сервлет имеет свой собственный экземпляр объекта `ServletConfig`, создаваемый контейнером сервлетов.

Для установки параметров конфигурации используются параметры `init-param` в `web.xml`:

```xml
<servlet>
    <servlet-name>ExampleServlet</servlet-name>
    <servlet-class>xyz.company.ExampleServlet</servlet-class>
    <init-param>
        <param-name>exampleParameter</param-name>
        <param-value>parameterValue</param-value>
    </init-param>
</servlet>
```

или аннотации `@WebInitParam`:

```java
@WebServlet(
    urlPatterns = "/example",
    initParams = {
        @WebInitParam(name = "exampleParameter", value = "parameterValue")
    }
)
public class ExampleServlet extends HttpServlet {
    //...
}
```

Для получения `ServletConfig` сервлета используется метод `getServletConfig()`.

### 12. Что представляет собой объект ServletContext?
Уникальный (в рамках веб-приложения) объект `ServletContext` реализует интерфейс `javax.servlet.ServletContext` и 
предоставляет сервлетам доступ к параметрам этого веб-приложения. Для предоставления доступа используется элемент 
`<context-param>` в `web.xml`:

```xml
<web-app>
    ...
    <context-param>
        <param-name>exampleParameter</param-name>
        <param-value>parameterValue</param-value>
    </context-param>
    ...
</web-app>
```

### 13. В чем отличия ServletContext и ServletConfig?
+ `ServletConfig` уникален для сервлета, а `ServletContext` - для приложения;
+ `ServletConfig` используется для предоставления параметров инициализации конкретному сервлету, 
а `ServletContext` для предоставления параметров инициализации для всех сервлетов приложения;
+ для `ServletConfig` возможности модифицировать атрибуты отсутствуют, атрибуты в объекте `ServletContext` можно изменять.

### 14. Что такое Request Dispatcher?
Интерфейс `RequestDispatcher` используется для передачи запроса другому ресурсу, при этом существует возможность 
добавления данных полученных из этого ресурса к собственному ответу сервлета. 
Так же этот интерфейс используется для внутренней коммуникации между сервлетами в одном контексте.  
+ `void forward(ServletRequest var1, ServletResponse var2)` — передает запрос из сервлета к другому 
ресурсу (сервлету, JSP или HTML файлу) на сервере.
+ `void include(ServletRequest var1, ServletResponse var2)` — включает контент ресурса (сервлет, JSP или HTML страница) 
в ответ.

### 15. Как можно создать блокировку (deadlock) в сервлете?
Дедлок можно получить реализовав зацикленный вызов метода, например, вызвав метод `doPost()` в методе `doGet()` 
и метод `doGet()` в методе `doPost()`.

### 16. Как получить адрес сервлета на сервере?
Реальный путь к расположению сервлета на сервере можно получить из объекта `ServletContext`: 
`getServletContext().getRealPath(request.getServletPath())`.

### 17. Как получить информацию о сервере из сервлета?
Информацию о сервере можно получить из объекта `ServletContext` с помощью метода `getServerInfo()`: 
`getServletContext().getServerInfo()`.

### 18. Как получить ip адрес клиента на сервере?
`request.getRemoteAddr()` используется для получения в сервлете IP адреса клиента на сервере.

### 19. Что вы знаете о классах обертках (wrapper) для сервлетов?
Данные классы-обертки помогают разработчикам реализовывать собственные реализации типов `request` и `response` сервлета. 
Можно расширить эти классы и переопределить только необходимые методы для реализации собственных типов объектов ответов и запросов. 
Эти классы не используются в стандартном программировании сервлетов.

### 20. Каков жизненный цикл сервлета и когда какие методы вызываются?
Контейнер сервлетов управляет четырьмя фазами жизненного цикла сервлета:

+ **Загрузка класса сервлета** — когда контейнер получает запрос для сервлета, то происходит загрузка класса сервлета в 
память и вызов его конструктора без параметров.
+ **Инициализация класса сервлета** — после того как класс загружен контейнер инициализирует объект `ServletConfig` для этого 
сервлета и внедряет его через `init()` метод. Это и есть место где сервлет класс преобразуется из обычного класса в сервлет.
+ **Обработка запросов** — после инициализации сервлет готов к обработке запросов. Для каждого запроса клиента сервлет 
контейнер порождает новый поток и вызывает метод `service()` путем передачи ссылки на объект ответы и запроса.
+ **Удаление из Service** - когда контейнер останавливается или останавливается приложение, то контейнер сервлетов 
уничтожает классы сервлетов путем вызова `destroy()` метода.

Таким образом, сервлет создаётся при первом обращении к нему и живёт на протяжении всего времени работы приложения 
(в отличии от объекты классов, которые уничтожаются сборщиком мусора после того как они уже не используются) и весь 
жизненный цикл сервлета можно описать как последовательность вызова методов:

+ `public void init(ServletConfig config)` – используется контейнером для инициализации сервлета. 
Вызывается один раз за время жизни сервлета.
+ `public void service(ServletRequest request, ServletResponse response)` – вызывается для каждого запроса. 
Метод не может быть вызван раньше выполнения `init()` метода.
+ `public void destroy()` – вызывается для уничтожения сервлета (один раз за время жизни сервлета).

### 21. Какие методы необходимо определить при создании сервлетов?
Наследуясь от `HttpServlet` и реализуем логику его работы 
в методе `service()` или методах `doGet()`/`doPost()`/...

### 22. В каком случае вы будете переопределять метод service()?
Метод `service()` переопределяется, когда необходимо, чтобы сервлет обрабатывал все запросы (и `GET`, и `POST`) в одном методе.
Когда контейнер сервлетов получает запрос клиента, то происходит вызов метода `service()`, 
который в зависимости от поступившего запроса вызывает или метод `doGet()` или метод `doPost()`.

### 23. Есть ли смысл определить конструктор для сервлета, как лучше инициализировать данные?
Такая возможность есть, но считается бессмысленной. 
Инициализировать данные лучше не в конструкторе, а переопределив метод `init()`, 
в котором имеется возможность доступа к параметрам инициализации сервлета через использование объекта `ServletConfig`.

### 24. В чем отличия GenericServlet и HttpServlet?
Абстрактный класс `GenericServlet` — независимая от используемого протокола реализация интерфейса `Servlet`, 
а абстрактный класс `HttpServlet` в свою очередь расширяет `GenericServlet` для протокола HTTP.  
Следует отметить, что HttpServlet extends GenericServlet.

### 25. Как вызвать из сервлета другой сервлет этого же и другого приложения?
Для вызова сервлета из того же приложения необходимо использовать механизм внутренней коммуникации сервлетов 
(_inter-servlet communication mechanisms_) через вызовы методов `RequestDispatcher` - `forward()` и `include()` 
для доступа к дополнительным атрибутам в запросе для использования в другом сервлете:
 
+ `forward()` - передаёт выполнение запроса в другой сервлет;
+ `include()` - предоставляет возможность включить результат работы другого сервлета в возвращаемый ответ.

Если необходимо вызывать сервлет принадлежащий другому приложению, то использовать `RequestDispatcher` уже не получится, 
т.к. он определен только для текущего приложения. Для подобных целей необходимо использовать 
метод `ServletResponse` - `sendRedirect()` которому предоставляется полный URL из другого сервлета. 
Для передачи данных между сервлетами можно использовать `cookies`. 
(т.е. можно использовать `cookies` как часть ответа сервлета, а потом использовать их в нашем сервлете)

### 26. Что вы знаете и в чем отличия методов forward() и sendRedirect()?
+ `RequestDispatcher forward()` используется для проброски того же самого запроса к другому ресурсу, 
в то время как `ServletResponse sendRedirect()` это двухшаговый метод. 
Во втором методе веб приложение возвращает ответ клиенту с `status code 302 (redirect)` с ссылкой для отправки запроса. 
Запрос посылает полностью новый запрос.
+ `forward()` обрабатывается внутри контейнера, а `sendRedirect()` обрабатывается браузером.
+ Необходимо использовать `forward()` для организации доступа внутри одного и того же приложения, 
т.к. он быстрее `sendRedirect()`, которому требуется дополнительная сетевая работа.
+ В методе `forward()` браузер не знает о фактически обрабатываемом ресурсе и URL в строке остается прежним. 
В `sendRedirect()` методе URL адрес изменяется на пробрасываемый ресурс.
+ В методе `forward()` нельзя использовать для внедрения сервлета в другой контекст. 
Для этого можно использовать только `sendRedirect()`.

### 27. Стоит ли волноваться о “многопоточной безопасности” работая с сервлетами?
Методы `init()` и `destroy()` вызываются один раз за жизненный цикл сервлета — поэтому по поводу них беспокоиться не стоит. 
Методы `doGet()`, `doPost()`, ... вызываются на каждый запрос клиента и т.к. сервлеты используют многопоточность, 
то здесь задумываться о потокобезопасной работе обязательно. 
При этом правила использования многопоточности остаются теми же: 
+ локальные переменные этих методов будут созданы отдельно для каждой нити. 
+ при использовании глобальных разделяемых ресурсов необходимо использовать синхронизацию или другие приёмы 
многопоточного программирования.

### 28. В чем отличие между веб сервером и сервером приложений?
Основное различие между веб-сервером и сервером приложений заключается в том, что веб-сервер предназначен для обслуживания статических страниц, например HTML и CSS, тогда как сервер приложений отвечает за генерацию динамического содержимого путем выполнения кода на стороне серверa.


### 29. Какой метод HTTP является (не)изменяемым?
+ HTTP метод называется неизменяемым, если он на один и тот же запрос всегда возвращает одинаковый результат. 
HTTP методы `GET`, `PUT`, `DELETE`, `HEAD` и `OPTIONS` являются неизменяемыми, поэтому необходимо реализовывать 
приложение так, чтобы эти методы возвращали одинаковый результат постоянно.

    Эти методы должны быть идемпотентными («idempotence») в том смысле, что повторное (более одного раза) выполнение
запросов с помощью этих методов будет иметь тот же эффект, что и однократное выполнение.

+ К изменяемым методам относится метод `POST`, который и используется для реализации чего-либо, что изменяется при каждом запросе.

К примеру, для доступа к статической HTML странице используется метод `GET`, т.к. он всегда возвращает одинаковый результат. 
При необходимости сохранять какую-либо информацию, например в базе данных, нужно использовать `POST` метод.
Неизменяемые методы так же известны как безопасные методы и нет необходимости заботиться о повторяющихся 
запросах от клиента для этих методов.

### 30. Почему HttpServlet класс объявлен как абстрактный?
Класс `HTTPServlet` объявлен как абстрактный, т.к. он предоставляет лишь общую реализацию сервлета для HTTP протокола. 
Реализация ключевых методов `doGet()` и `doPost()`, содержащих основную бизнес-логику перекладывается на разработчика 
и по умолчанию возвращает `HTTP 405 Method Not Implemented error`.

### 31. В чем разница между методами GET и POST?
+ `GET` передает данные серверу используя URL, тогда как `POST` передает данные, используя тело HTTP запроса. 
Длина URL ограничена 1024 символами, это и будет верхним ограничением для данных, 
которые можно отослать через `GET`. `POST` может отправлять гораздо большие объемы данных. 
Лимит устанавливается `web-server` и составляет обычно около 2 Mb.
+ Данные `GET` метода передаются в открытом виде, `POST` данные передаются в теле запроса и скрыты от пользователя.
Поэтому передача данных методом `POST` более безопасна, чем методом `GET`, т.к. секретные данные (например пароль) 
не отображаются напрямую в web-клиенте пользователя, в отличии от URL, который виден почти всегда. 
Иногда это преимущество становится недостатоком - вы не сможете послать данные за кого-то другого.
+ `GET`метод является неизменяемым, тогда как `POST` — изменяемый.
+ `GET` метод является HTTP методом по умолчанию, а `POST` метод необходимо указывать явно, чтобы отправить запрос.
+ `GET` метод используется гиперссылками на странице.

### 32. Что такое MIME-тип?
`Content-Type response header` это и есть MIME тип.
 
Сервер посылает MIME тип клиенту для того, чтобы он понял какой тип данных пересылается. 
Это помогает верно отобразить полученные данные на клиенте. 

Наиболее часто используемые MIME типы: text/html, text/xml, application/xml и многие др.
В `ServletContext` существует метод `getMimeType()` для получения корректного MIME типа файла 
и дальнейшего использования этой информации для указания типа контента в ответе.

### 33. Назовите преимущества Servlet над CGI?

Технология сервлетов была создана для преодоления недостатков Common Gateway Interface (общий интерфейс шлюза). 
Можно выделить следующие преимущества сервлетов над CGI:

+ **Быстродействие.** Сервлеты предоставляют лучшую производительность в условиях обработки запросов, 
лучшее использование памяти за счет использования преимущество многопоточности 
(на каждый запрос создается новая нить, что быстрее выделения памяти под новый объект для каждого запроса, как это происходит в CGI).
+ **Переносимость на различные платформы.** Сервлеты, платформа и система являются независимыми. 
Т.е. веб приложение написанное с использованием сервлетов может быть запущено в любом контейнере сервлетов, 
реализующим стандарт и в любой операционной системе.
+ **Надежность.** Использование сервлетов повышает надежность программы, 
т.к. контейнер сервлетов самостоятельно заботится о жизненном цикле сервлетов (а значит и за утечками памяти), 
безопасности и сборщике мусора.
+ Сервлеты относительно легки в изучении и поддержке, поэтому разработчику необходимо заботиться только о бизнес логике приложения, 
а не внутренней реализации веб технологий.

### 34. Каковы наиболее распространенные задачи выполняются в Servlet контейнере?
+ **Поддержка обмена данными**. Контейнер сервлетов предоставляет легкий способ обмена данными между веб клиентом (браузером) и сервлетом. 
Благодаря контейнеру нет необходимости создавать слушателя сокета на сервере для отслеживания запросов от клиента, 
а так же разбирать запрос и генерировать ответ. 
Все эти важные и комплексные задачи решаются с помощью контейнера и разработчик может сосредоточиться на бизнес логике приложения.
+ **Управление жизненным циклом сервлетов и ресурсов**. Начиная от загрузки сервлета в память, инициализации, внедрения методов и заканчивая уничтожением сервлета. 
Контейнер так же предоставляет дополнительные утилиты, например JNDI, для управления пулом ресурсов.
+ **Поддержка многопоточности**. Контейнер самостоятельно создает новую нить для каждого запроса и предоставляет ей запрос и ответ для обработки. 
Таким образом сервлет не инициализируется заново для каждого запроса и тем самым сохраняет память и уменьшает время до обработки запроса.
+ **Поддержка JSP**. JSP классы не похожи на стандартные классы джавы, но контейнер сервлетов преобразует каждую JSP в сервлет и далее управляется контейнером как обычным сервлетом.
+ **Различные задачи**. Контейнер сервлетов управляет пулом ресурсов, памятью приложения, сборщиком мусора. Предоставляются возможности настройки безопасности и многое другое.

### 35. В чем разница между PrintWriter и ServletOutputStream?
`PrintWriter` — это класс для работы с символьным потоком, а `ServletOutputStream` — класс для работы байтовым потоком. 

`PrintWriter` используется для записи информации на основе символов, вроде массива символов или строки в ответ, 
в то время как `ServletOutputStream` используется для записи в ответ массива байтов. 

Для получения экземпляра `ServletOutputStream` используется метод `ServletResponse` `getOutputStream()`, 
а для `PrintWriter` — метод `ServletResponse` `getWriter()`.

### 36. Можем ли мы получить PrintWriter и ServletOutputStream одновременно в сервлете?
Мы не можем создать объекты этих классов в одном сервлете. 
При попытке одновременного вызова `getWriter()` и `getOutputStream()` будет выброшено 
исключение `java.lang.IllegalStateException` с сообщением, что уже был вызван другой метод.

### 37. Расскажите о интерфейсе SingleThreadModel.
Для каждого обращения создает свой экземпляр servleta, гарантирует потоко безопасноть. Устарел.

### 38. Какие существуют атрибуты у сервлетов и какая сфера их применения?
Атрибуты сервлетов используются для внутренней коммуникации сервлетов.  
В веб-приложении существует возможность работы с атрибутами используя методы `setAttribute()`, `getAttribute()`, 
`removeAttribute()`, `getAttributeNames()`, которые предоставлены интерфейсами `ServletRequest`, `HttpSession` и 
`ServletContext` (для областей видимости _request scope_, _session scope_, _context scope_ соответственно).

### 39. Почему необходимо переопределить только init() метод без аргументов?
Метод `init()` переопределяется, если необходимо инициализировать какие-то данные до того как сервлет начнет 
обрабатывать запросы. 

При переопределении метода `init(ServletConfig config)`, первым должен быть вызван метод `super(config)`, который 
обеспечит вызов метода `init(ServletConfig config)` суперкласса. 

`GenericServlet` предоставляет другой метод `init()` без параметров, который будет вызываться в конце метода `init(ServletConfig config)`.

Необходимо использовать переопределенный метод `init()` без параметров для инициализации данных во избежание 
каких-либо проблем, например ошибки, когда вызов `super()` не указан в переопределенном `init(ServletConfig config)`.

### 40. Что означает URL encoding? Зачем нужны методы java.net.URLEncoder.encode() и decode()?
В Java для кодирования строки используется метод `java.net.URLEncoder.encode(String str, String unicode)`. 
Обратная операция декодирования возможна через использование метода `java.net.URLDecoder.decode(String str, String unicode)`. 

Примеры работы метода:

> `Hello мир!` преобразовывается в `Hello%20%D0%BC%D0%B8%D1%80!`

> `Java for study .ru` преобразовается в `Java%20for%20study%20.ru`

### 41. Зачем нужны и чем отличаются методы encodeUrl() и encodeRedirectUrl()?
`HttpServletResponse.encodeURL()` предоставляет способ преобразования URL в HTML гиперссылку с преобразованием 
спецсимволов и пробелов, а так же добавления _session id_ к URL. 
Такое поведение аналогично `java.net.URLEncoder.encode()`, но с добавлением дополнительного параметра `jsessionid` в конец URL.

Метод `HttpServletResponse.encodeRedirectURL()` преобразует URL для последующего использования в методе `sendRedirect()`. 

Таким образом для HTML гиперссылок при _URL rewriting_ необходимо использовать `encodeURL()`, 
а для URL при перенаправлении - `encodeRedirectUrl()`.

### 42. Какие различные методы управления сессией в сервлетах вы знаете?
__Сессия__ - это сеанс связи между клиентом и сервером, устанавливаемый на определенное время. 
Сеанс устанавливается непосредственно между клиентом и веб-сервером в момент получения первого запроса к веб-приложению. 
Каждый клиент устанавливает с сервером свой собственный сеанс, который сохраняется до окончания работы с приложением.

Сессии используются для обеспечения хранения данных во время нескольких запросов Web-страницы или на обработку информации, 
введенной в пользовательскую форму в результате нескольких HTTP-соединений (например, клиент совершает несколько покупок 
в интернет-магазине; студент отвечает на несколько тестов в системе дистанционного обучения). 

Сессия может содержать в себе множество запросов и ответов клиент-сервер.
Т.к. HTTP и веб сервер не запоминают состояния (stateless), то единственным способом поддерживать 
сессию является пересылка уникальной информации (session id) в каждом запросе и ответе между клиентом и сервером.

Существует несколько способов управления сессией (обеспечения ее уникального идентификатора) в сервлетах:

+ __User Authentication__ – Предоставление учетных данных самим пользователем в момент аутентификации. 
Переданная таким образом информация в дальнейшем используется для поддержания сеанса. 
Это метод не будет работать, если пользователь вошёл в систему одновременно из нескольких мест.
+ __HTML Hidden Field__ – Присвоение уникального значения скрытому полю HTML страницы, 
в момент когда пользователь начинает сеанс. Этот метод не может быть использован со ссылками, потому что нуждается в 
подтверждении формы со скрытым полем каждый раз во время формирования запроса. 
Кроме того, это не безопасно, т.к. существует возможность простой подмены такого идентификатора.
+ __URL Rewriting__ – Добавление идентификатора сеанса как параметра URL. Достаточно утомительная операция, 
потому что требует постоянного отслеживания этого идентификатора при каждом запросе или ответе.
+ __Cookies__ – Использование небольших фрагментов данных, отправленных web-сервером и хранимых на устройстве пользователя. 
Данный метод не будет работать, если клиент отключает использование cookies.
+ __Session Management API__ – Использование специального API для отслеживания сеанса, построенный на основе 
и на методах описанных выше и который решает частные проблемы перечисленных способов:
    + Чаще всего недостаточно просто отслеживать сессию, необходимо ещё и сохранять какие-либо дополнительные данные о ней, 
    которые могут потребоваться при обработке последующих запросов. Осуществление такого поведения требует много дополнительных усилий.
    + Все вышеперечисленные методы не являются универсальными: для каждого из них можно подобрать конкретный сценарий, 
    при котором они не будут работать.

### 43. Что означает URL Rewriting?
Для управления сессией в сервлетах мы можем использовать HTTPSession, но он работает с Cookies, а их иногда отключают. Для этого случая в сервлетах предусмотрена возможность URL Rewriting. С точки зрения программирования необходимо всего одно действие – кодирование URL. Другим достоинством является то, что этот метод является как бы запасным и включается только при выключенных куках.

Применяя метод HttpServletResponse encodeURL() мы можем закодировать URL. Если необходим редирект к другому ресурсу, то для предоставления информации о сессии применяется метод encodeRedirectURL().

### 44. Как применяются Cookies в сервлетах?
__Сookies («куки»)__ — небольшой фрагмент данных, отправленный web-сервером и хранимый на устройстве пользователя. 
Всякий раз при попытке открыть страницу сайта, web-клиент пересылает соответствующие этому сайту cookies web-серверу 
в составе HTTP-запроса. 

Применяется для сохранения данных на стороне пользователя и на практике обычно используется для:
+ аутентификации пользователя;
+ хранения персональных предпочтений и настроек пользователя;
+ отслеживания состояния сеанса доступа пользователя;
+ ведения разнообразной статистики.

Cookies (куки) используются в клиент-серверном взаимодействии и они не являются чем-то конкретным к Java. 
Servlet API предоставляет поддержку cookies через класс `javax.servlet.http.Cookie` `implements Serializable, Cloneable`:

+ Для получения массива cookies из запроса необходимо воспользоваться методом `HttpServletRequest.getCookies()`. 
Методов для добавления cookies в запрос `HttpServletRequest` не предусмотрено.
+ Для добавления cookie в ответ используется `HttpServletResponse.addCookie(Cookie c)`. 
Метода получения cookies в `HttpServletResponse` отсутствует.

### 45. Как уведомить объект в сессии, что сессия недействительна или закончилась?
Чтобы быть уверенным в том, что объект будет оповещён о прекращении сессии, нужно реализовать интерфейс 
`javax.servlet.http.HttpSessionBindingListener`. 

Два метода этого интерфейса: `valueBound()` и `valueUnbound()` используются для реализации логики при добавлении 
объекта в качестве атрибута к сессии и при уничтожении сессии соответственно.

### 46. Какой существует эффективный способ удостоверится, что все сервлеты доступны только для пользователя с валидной сессией?
Сервлет фильтры используются для перехвата всех запросов между контейнером сервлетов и сервлетом. 
Поэтому логично использовать соответствующий фильтр для проверки необходимой информации (например валидности сессии) в запросе.

### 47. Как мы можем обеспечить transport layer security для нашего веб приложения?
Для обеспечения _transport layer security_ необходимо настроить поддержку SSL для вашего сервлет контейнера. 
Как это сделать описано в мануалах для конкретной реализации сервлет-контейнера.

SSL (англ. Secure Sockets Layer — уровень защищённых сокетов) — семейство криптографических протоколов для установки 
шифрованного соединения между двумя сторонами, желающими обмениваться данными. 

### 48. Как организовать подключение к базе данных и обеспечить логирование log4j в сервлете?
При работе с большим количеством подключений к базе данных рекомендуется инициализировать их в _servlet context listener_, 
а также установить в качестве атрибута контекста для возможности использования другими сервлетами. 

Логирование Log4j подключается к сервлету с помощью _property_-файла или XML-конфигурации, 
а далее эта информация используется при конфигурировании соответствующего _context listener_.

Servlet Example in Java with Database Connection and Log4j integration
http://www.journaldev.com/1997/servlet-example-in-java-with-database-connection-and-log4j-integration

У нас будет файл конфигурации log4j внутри папки WEB-INF, и он будет упакован с файлом WAR приложения.

Код log4j.xml:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
<log4j:configuration xmlns:log4j="https://jakarta.apache.org/log4j/"
	debug="false">
	<appender name="dbexample" class="org.apache.log4j.RollingFileAppender">
		<param name="File" value="${catalina.home}/logs/dbexample.log"/>
		<param name="Append"            value="true" />
		<param name="ImmediateFlush"    value="true" />
		<param name="MaxFileSize"       value="20MB" />
		<param name="MaxBackupIndex"    value="10" />
		<layout class="org.apache.log4j.PatternLayout">
			<param name="ConversionPattern" value="%-4r [%t] %-5p %c %x - %m%n" />
		</layout>
	</appender>
	
	<logger name="com.journaldev" additivity="false">
		<level value="DEBUG" />
		<appender-ref ref="dbexample"/>
	</logger>
	
	<root>
		<level value="debug" />
		<appender-ref ref="dbexample" />
	</root>
	
</log4j:configuration>
```
Наш дескриптор развертывания (web.xml) выглядит так, как показано ниже.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance" xmlns="https://java.sun.com/xml/ns/javaee" xsi:schemaLocation="https://java.sun.com/xml/ns/javaee https://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0">
  <display-name>ServletDBLog4jExample</display-name>
  <welcome-file-list>
    <welcome-file>login.html</welcome-file>
  </welcome-file-list>
  <context-param>
    <param-name>dbUser</param-name>
    <param-value>pankaj</param-value>
  </context-param>
  <context-param>
    <param-name>dbPassword</param-name>
    <param-value>pankaj123</param-value>
  </context-param>
  <context-param>
    <param-name>dbURL</param-name>
    <param-value>jdbc:mysql://localhost:3306/UserDB</param-value>
  </context-param>
  <context-param>
    <param-name>log4j-config</param-name>
    <param-value>WEB-INF/log4j.xml</param-value>
  </context-param>
  
  <error-page>
    <error-code>404</error-code>
    <location>/AppErrorHandler</location>
  </error-page>
  <error-page>
    <exception-type>java.lang.Throwable</exception-type>
    <location>/AppErrorHandler</location>
  </error-page>
  
  <filter>
    <filter-name>AuthenticationFilter</filter-name>
    <filter-class>com.journaldev.servlet.filters.AuthenticationFilter</filter-class>
  </filter>
  <filter-mapping>
    <filter-name>AuthenticationFilter</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>
  
</web-app>
```
Обратите внимание на следующие моменты в конфигурации web.xml.

login.html - это файл приветствия в списке файлов приветствия.
Параметры подключения к базе данных сделаны настраиваемыми и хранятся как параметры инициализации контекста сервлета.
Расположение файла конфигурации log4j также настраивается, а относительное расположение указывается как параметр context init.
Наш настраиваемый сервлет обработчика исключений AppErrorHandler настроен для обработки всех исключений, вызванных нашим кодом приложения и ошибками 404.
AuthenticationFilter настроен для фильтрации всех входящих запросов к приложению, это место, где у нас будет логика проверки сеанса.

DBConnectionManager.java - это служебный класс для подключения к базе данных MySql, у которого есть метод, который возвращает объект подключения. Мы будем использовать этот класс для подключения к базе данных, а затем установим для объекта подключения атрибут контекста сервлета, который могут использовать другие сервлеты.

```java
package com.journaldev.util;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class DBConnectionManager {

	private Connection connection;
	
	public DBConnectionManager(String dbURL, String user, String pwd) throws ClassNotFoundException, SQLException{
		Class.forName("com.mysql.jdbc.Driver");
		this.connection = DriverManager.getConnection(dbURL, user, pwd);
	}
	
	public Connection getConnection(){
		return this.connection;
	}
}
```
AppContextListener.java - это реализация прослушивателя контекста сервлета, которая инициализирует соединение с базой данных при инициализации контекста приложения, а также настраивает log4j, используя его конфигурационный xml-файл. Обратите внимание на использование параметров контекстной инициализации для подключения к БД и конфигурации log4j.

Когда контекст будет уничтожен, мы закрываем соединение с базой данных в методе contextDestroyed ().

Поскольку мы используем Servlet 3, нам не нужно настраивать его в web.xml, и нам просто нужно аннотировать его аннотацией @WebListener.

```java
package com.journaldev.servlet.listeners;

import java.io.File;
import java.sql.Connection;
import java.sql.SQLException;

import javax.servlet.ServletContext;
import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import javax.servlet.annotation.WebListener;

import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.xml.DOMConfigurator;

import com.journaldev.util.DBConnectionManager;

@WebListener
public class AppContextListener implements ServletContextListener {

    public void contextInitialized(ServletContextEvent servletContextEvent) {
    	ServletContext ctx = servletContextEvent.getServletContext();
    	
    	//initialize DB Connection
    	String dbURL = ctx.getInitParameter("dbURL");
    	String user = ctx.getInitParameter("dbUser");
    	String pwd = ctx.getInitParameter("dbPassword");
    	
    	try {
			DBConnectionManager connectionManager = new DBConnectionManager(dbURL, user, pwd);
			ctx.setAttribute("DBConnection", connectionManager.getConnection());
			System.out.println("DB Connection initialized successfully.");
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		} catch (SQLException e) {
			e.printStackTrace();
		}
    	
    	//initialize log4j
    	String log4jConfig = ctx.getInitParameter("log4j-config");
    	if(log4jConfig == null){
    		System.err.println("No log4j-config init param, initializing log4j with BasicConfigurator");
			BasicConfigurator.configure();
    	}else {
			String webAppPath = ctx.getRealPath("/");
			String log4jProp = webAppPath + log4jConfig;
			File log4jConfigFile = new File(log4jProp);
			if (log4jConfigFile.exists()) {
				System.out.println("Initializing log4j with: " + log4jProp);
				DOMConfigurator.configure(log4jProp);
			} else {
				System.err.println(log4jProp + " file not found, initializing log4j with BasicConfigurator");
				BasicConfigurator.configure();
			}
		}
    	System.out.println("log4j configured properly");
    }

    public void contextDestroyed(ServletContextEvent servletContextEvent) {
    	Connection con = (Connection) servletContextEvent.getServletContext().getAttribute("DBConnection");
    	try {
			con.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
    }
	
}
```

### 49. Какие важные особенности существуют в Servlet 3?
+ __Servlet Annotations__. До Servlet 3 весь маппинг (конфигурация) содержался в `web.xml`, что приводило к ошибкам и неудобству 
при работе с большим количестве сервлетов. Примеры аннотаций: `@WebServlet`, `@WebInitParam`, `@WebFilter`, `@WebListener`.
+ __Web Fragments__. Одностраничное веб приложение может содержать множество модулей: все модули прописываются 
в `fragment.xml` в папке `META-INF\`. Это позволяет разделять веб приложение на отдельные модули, 
собранные как JAR-файлы в отдельной `lib\` директории.
+ __Динамическое добавление веб компонентов__. Появилась возможность программно добавлять фильтры и слушатели, 
используя `ServletContext` объект. Для этого применяются методы `addServlet()`, `addFilter()`, `addListener()`. 
Это помогает построить динамическую систему, в которой необходимый объект будет вызван только по необходимости.
+ __Асинхронное выполнение__. Поддержка асинхронной обработки позволяет передать выполнение запроса в другой поток 
без удержания всего сервера занятым.

http://www.journaldev.com/2008/async-servlet-feature-of-servlet-3

### 50. Каковы различные способы аутентификации сервлета?
Спецификация сервлетов определяет четыре типа аутентификации (проверки подлинности):

+ __HTTP Basic Authentication__ - `BASIC`. При доступе к закрытым ресурсам появится окно, которое попросит ввести 
данные для аутентификации.
+ __Form Based Login__ - `FORM`. Используется собственная html форма:
+ __HTTP Digest Authentication__ - `DIGEST`. Цифровая аутентификация с шифрованием.
+ __HTTPS Authentication__ - `CLIENT-CERT`. Аутентификация с помощью клиентского сертификата.

```xml
<login-config>
    <auth-method>FORM</auth-method>
    <form-login-config>
        <form-login-page>/login.html</form-login-page>
        <form-error-page>/error.html</form-error-page>
    </form-login-config>
</login-config>
```

### 51. Написать сервлет, реализующий загрузку файла на сервер? 
```java
@MultipartConfig
public class UploadServlet extends HttpServlet {
...
for (Part part : req.getParts()) { //part - файл в запросе
      ...
            part.write(uploadFilePath); //куда и как(название) записать
      ...
   }
...
}
```

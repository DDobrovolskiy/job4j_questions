### 1. Что такое сервлет?
Сервлет представляет специальный тип классов Java, который выполняется на веб-сервере и который обрабатывает запросы и возвращает результат обработки.

### 2. Какова структура веб-проекта?
```xml
  ├── pom.xml  
  └── src  
    ├── main  
      │   ├── java  
      │   │   └── mygroup  
      │   │       ├── controller  
      │   │       │   ├── HomeController.java  
      │   │       │   └── PersonController.java  
      │   │       ├── dao  
      │   │       │   └── PersonDao.java  
      │   │       └── model  
      │   │           └── Person.java  
      │   ├── resources  
      │   │   ├── db.properties  
      │   │   ├── log4j.xml  
      │   │   └── META-INF  
      │   │       └── persistence.xml  
      │   └── webapp  
      │       ├── index.html  
      │       ├── META-INF  
      │       │   ├── context.xml  
      │       │   └── MANIFEST.MF  
      │       ├── resources  
      │       │   └── css  
      │       │       └── screen.css  
      │       └── WEB-INF  
      │           ├── spring  
      │           │   ├── app  
      │           │   │   ├── controllers.xml  
      │           │   │   └── servlet-context.xml  
      │           │   ├── db.xml  
      │           │   └── root-context.xml  
      │           ├── views  
      │           │   ├── edit.jsp  
      │           │   ├── home.jsp  
      │           │   └── list.jsp  
      │           └── web.xml  
      └── test  
          ├── java  
          │   └── mygroup  
          │       ├── controller  
          │       │   ├── DataInitializer.java  
          │       │   ├── HomeControllerTest.java  
          │       │   └── PersonControllerTest.java  
          │       └── dao  
          │           └── PersonDaoTest.java  
          └── resources  
              ├── db.properties  
              ├── log4j.xml  
              ├── test-context.xml  
              └── test-db.xml  
```

### 3. Что такое контейнер сервлетов?
Контейнер сервлетов — программа, представляющая собой сервер, который занимается системной поддержкой сервлетов и обеспечивает их жизненный цикл в соответствии с правилами, определёнными в спецификациях.

### 4. Каковы задачи, функциональность контейнера сервлетов?
Контейнер сервлетов может работать как полноценный самостоятельный веб-сервер, быть поставщиком страниц для другого веб-сервера, например Apache, или интегрироваться в Java EE сервер приложений. Обеспечивает обмен данными между сервлетом и клиентами, берёт на себя выполнение таких функций, как создание программной среды для функционирующего сервлета, идентификацию и авторизацию клиентов, организацию сессии для каждого из них.

### 5. Что вы знаете о сервлет фильтрах?
Сервлет-фильтр используется для контроля запроса и ответа клиента на сервлет или для изменения запроса и ответа, а также для аудита и регистрации.

### 6. Зачем нужны слушатели в сервлетах?
Слушатель сервлета используется для прослушивания событий в веб-контейнерах, например, при создании сеанса или размещения атрибута в сеансе или при пассиве и активации в другом контейнере для подписки на эти события

### 7. Когда вы будете использовать фильтры сервлетов, а когда слушатели?
Следует использовать фильтры, если необходимо обрабатывать входящие или исходящие данные (например: для аутентификации, преобразования формата, компрессии, шифрования и т.д.), в случае, когда необходимо реагировать на события - лучше применять слушателей.

### 8. Как обработать исключения, выброшенные другим сервлетом в приложении?
Когда приложение выбрасывет исключение контейнер сервлетов обрабатывает его и создаёт ответ в формате HTML.
(т.е. контейнер создаст HTTP response, т.к. браузер понимает только HTTP)
Это аналогично тому что происходит при кодах ошибок вроде 404, 403 и т.д.

В дополнении к этому существует возможность написания собственных сервлетов для обработки исключений и ошибок 
с указанием их в дескрипторе развертывания:

```xml
<error-page>
    <error-code>404</error-code>
    <location>/AppExceptionHandler</location>
</error-page>
<error-page>
    <exception-type>javax.servlet.ServletException</exception-type>
    <location>/AppExceptionHandler</location>
</error-page>
```

Основная задача таких сервлетов - обработать ошибку/исключение и сформировать понятный HTTP ответ пользователю. 
Например, предоставить ссылку на главную страницу или же описание некоторых деталей об ошибке.

http://www.journaldev.com/1973/servlet-exception-and-error-handling-example-tutorial

### 9. Что такое дескриптор развертывания?
Дескриптор развертывания веб-приложений описывает классы, ресурсы и конфигурацию приложения, а так же как сервер будет использовать их для выполнения веб-запросов. Когда сервер получает запрос для приложения, он использует дескриптор развертывания для отображения URL запроса к коду, который должен этот запрос обработать.

### 10. Как реализовать запуск сервлета с запуском приложения?

Контейнер сервлетов обычно загружает сервлет по первому запросу клиента.

Если необходимо загрузить сервлет прямо на старте приложения (например если загрузка сервлета происходит длительное время) 
следует использовать элемент `<load-on-startup>` в дескрипторе или аннотацию `@loadOnStartup` в коде сервлета, 
что будет указывать на необходимость загрузки сервлета при запуске.

Значение должно быть целочисленное `int`. Если значение отрицательное, то сервлет будет загружен при запросе клиента. 
В противном случае (0 и далее) - загрузится на старте приложения. 
Чем число меньше, тем раньше в очереди на загрузку окажется сервлет.

```xml
<servlet>
    <servlet-name>ExampleServlet</servlet-name>
    <servlet-class>xyz.company.ExampleServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
</servlet>
```

### 11. Что представляет собой объект ServletConfig?
Интерфейс `javax.servlet.ServletConfig` используется для передачи сервлету конфигурационной информации. 
Каждый сервлет имеет свой собственный экземпляр объекта `ServletConfig`, создаваемый контейнером сервлетов.

Для установки параметров конфигурации используются параметры `init-param` в `web.xml`:

```xml
<servlet>
    <servlet-name>ExampleServlet</servlet-name>
    <servlet-class>xyz.company.ExampleServlet</servlet-class>
    <init-param>
        <param-name>exampleParameter</param-name>
        <param-value>parameterValue</param-value>
    </init-param>
</servlet>
```

или аннотации `@WebInitParam`:

```java
@WebServlet(
    urlPatterns = "/example",
    initParams = {
        @WebInitParam(name = "exampleParameter", value = "parameterValue")
    }
)
public class ExampleServlet extends HttpServlet {
    //...
}
```

Для получения `ServletConfig` сервлета используется метод `getServletConfig()`.

### 12. Что представляет собой объект ServletContext?
Уникальный (в рамках веб-приложения) объект `ServletContext` реализует интерфейс `javax.servlet.ServletContext` и 
предоставляет сервлетам доступ к параметрам этого веб-приложения. Для предоставления доступа используется элемент 
`<context-param>` в `web.xml`:

```xml
<web-app>
    ...
    <context-param>
        <param-name>exampleParameter</param-name>
        <param-value>parameterValue</param-value>
    </context-param>
    ...
</web-app>
```

### 13. В чем отличия ServletContext и ServletConfig?
+ `ServletConfig` уникален для сервлета, а `ServletContext` - для приложения;
+ `ServletConfig` используется для предоставления параметров инициализации конкретному сервлету, 
а `ServletContext` для предоставления параметров инициализации для всех сервлетов приложения;
+ для `ServletConfig` возможности модифицировать атрибуты отсутствуют, атрибуты в объекте `ServletContext` можно изменять.

### 14. Что такое Request Dispatcher?
Интерфейс `RequestDispatcher` используется для передачи запроса другому ресурсу, при этом существует возможность 
добавления данных полученных из этого ресурса к собственному ответу сервлета. 
Так же этот интерфейс используется для внутренней коммуникации между сервлетами в одном контексте.  
+ `void forward(ServletRequest var1, ServletResponse var2)` — передает запрос из сервлета к другому 
ресурсу (сервлету, JSP или HTML файлу) на сервере.
+ `void include(ServletRequest var1, ServletResponse var2)` — включает контент ресурса (сервлет, JSP или HTML страница) 
в ответ.

### 15. Как можно создать блокировку (deadlock) в сервлете?
Дедлок можно получить реализовав зацикленный вызов метода, например, вызвав метод `doPost()` в методе `doGet()` 
и метод `doGet()` в методе `doPost()`.

### 16. Как получить адрес сервлета на сервере?
Реальный путь к расположению сервлета на сервере можно получить из объекта `ServletContext`: 
`getServletContext().getRealPath(request.getServletPath())`.

### 17. Как получить информацию о сервере из сервлета?
Информацию о сервере можно получить из объекта `ServletContext` с помощью метода `getServerInfo()`: 
`getServletContext().getServerInfo()`.

### 18. Как получить ip адрес клиента на сервере?
`request.getRemoteAddr()` используется для получения в сервлете IP адреса клиента на сервере.

### 19. Что вы знаете о классах обертках (wrapper) для сервлетов?
Данные классы-обертки помогают разработчикам реализовывать собственные реализации типов `request` и `response` сервлета. 
Можно расширить эти классы и переопределить только необходимые методы для реализации собственных типов объектов ответов и запросов. 
Эти классы не используются в стандартном программировании сервлетов.

### 20. Каков жизненный цикл сервлета и когда какие методы вызываются?
Контейнер сервлетов управляет четырьмя фазами жизненного цикла сервлета:

+ **Загрузка класса сервлета** — когда контейнер получает запрос для сервлета, то происходит загрузка класса сервлета в 
память и вызов его конструктора без параметров.
+ **Инициализация класса сервлета** — после того как класс загружен контейнер инициализирует объект `ServletConfig` для этого 
сервлета и внедряет его через `init()` метод. Это и есть место где сервлет класс преобразуется из обычного класса в сервлет.
+ **Обработка запросов** — после инициализации сервлет готов к обработке запросов. Для каждого запроса клиента сервлет 
контейнер порождает новый поток и вызывает метод `service()` путем передачи ссылки на объект ответы и запроса.
+ **Удаление из Service** - когда контейнер останавливается или останавливается приложение, то контейнер сервлетов 
уничтожает классы сервлетов путем вызова `destroy()` метода.

Таким образом, сервлет создаётся при первом обращении к нему и живёт на протяжении всего времени работы приложения 
(в отличии от объекты классов, которые уничтожаются сборщиком мусора после того как они уже не используются) и весь 
жизненный цикл сервлета можно описать как последовательность вызова методов:

+ `public void init(ServletConfig config)` – используется контейнером для инициализации сервлета. 
Вызывается один раз за время жизни сервлета.
+ `public void service(ServletRequest request, ServletResponse response)` – вызывается для каждого запроса. 
Метод не может быть вызван раньше выполнения `init()` метода.
+ `public void destroy()` – вызывается для уничтожения сервлета (один раз за время жизни сервлета).

### 21. Какие методы необходимо определить при создании сервлетов?
Наследуясь от `HttpServlet` и реализуем логику его работы 
в методе `service()` или методах `doGet()`/`doPost()`/...

### 22. В каком случае вы будете переопределять метод service()?
Метод `service()` переопределяется, когда необходимо, чтобы сервлет обрабатывал все запросы (и `GET`, и `POST`) в одном методе.
Когда контейнер сервлетов получает запрос клиента, то происходит вызов метода `service()`, 
который в зависимости от поступившего запроса вызывает или метод `doGet()` или метод `doPost()`.

### 23. Есть ли смысл определить конструктор для сервлета, как лучше инициализировать данные?
Такая возможность есть, но считается бессмысленной. 
Инициализировать данные лучше не в конструкторе, а переопределив метод `init()`, 
в котором имеется возможность доступа к параметрам инициализации сервлета через использование объекта `ServletConfig`.

### 24. В чем отличия GenericServlet и HttpServlet?
Абстрактный класс `GenericServlet` — независимая от используемого протокола реализация интерфейса `Servlet`, 
а абстрактный класс `HttpServlet` в свою очередь расширяет `GenericServlet` для протокола HTTP.  
Следует отметить, что HttpServlet extends GenericServlet.

### 25. Как вызвать из сервлета другой сервлет этого же и другого приложения?
Для вызова сервлета из того же приложения необходимо использовать механизм внутренней коммуникации сервлетов 
(_inter-servlet communication mechanisms_) через вызовы методов `RequestDispatcher` - `forward()` и `include()` 
для доступа к дополнительным атрибутам в запросе для использования в другом сервлете:
 
+ `forward()` - передаёт выполнение запроса в другой сервлет;
+ `include()` - предоставляет возможность включить результат работы другого сервлета в возвращаемый ответ.

Если необходимо вызывать сервлет принадлежащий другому приложению, то использовать `RequestDispatcher` уже не получится, 
т.к. он определен только для текущего приложения. Для подобных целей необходимо использовать 
метод `ServletResponse` - `sendRedirect()` которому предоставляется полный URL из другого сервлета. 
Для передачи данных между сервлетами можно использовать `cookies`. 
(т.е. можно использовать `cookies` как часть ответа сервлета, а потом использовать их в нашем сервлете)

### 26. Что вы знаете и в чем отличия методов forward() и sendRedirect()?
+ `RequestDispatcher forward()` используется для проброски того же самого запроса к другому ресурсу, 
в то время как `ServletResponse sendRedirect()` это двухшаговый метод. 
Во втором методе веб приложение возвращает ответ клиенту с `status code 302 (redirect)` с ссылкой для отправки запроса. 
Запрос посылает полностью новый запрос.
+ `forward()` обрабатывается внутри контейнера, а `sendRedirect()` обрабатывается браузером.
+ Необходимо использовать `forward()` для организации доступа внутри одного и того же приложения, 
т.к. он быстрее `sendRedirect()`, которому требуется дополнительная сетевая работа.
+ В методе `forward()` браузер не знает о фактически обрабатываемом ресурсе и URL в строке остается прежним. 
В `sendRedirect()` методе URL адрес изменяется на пробрасываемый ресурс.
+ В методе `forward()` нельзя использовать для внедрения сервлета в другой контекст. 
Для этого можно использовать только `sendRedirect()`.

### 27. Стоит ли волноваться о “многопоточной безопасности” работая с сервлетами?
Методы `init()` и `destroy()` вызываются один раз за жизненный цикл сервлета — поэтому по поводу них беспокоиться не стоит. 
Методы `doGet()`, `doPost()`, ... вызываются на каждый запрос клиента и т.к. сервлеты используют многопоточность, 
то здесь задумываться о потокобезопасной работе обязательно. 
При этом правила использования многопоточности остаются теми же: 
+ локальные переменные этих методов будут созданы отдельно для каждой нити. 
+ при использовании глобальных разделяемых ресурсов необходимо использовать синхронизацию или другие приёмы 
многопоточного программирования.

### 28. В чем отличие между веб сервером и сервером приложений?
Основное различие между веб-сервером и сервером приложений заключается в том, что веб-сервер предназначен для обслуживания статических страниц, например HTML и CSS, тогда как сервер приложений отвечает за генерацию динамического содержимого путем выполнения кода на стороне серверa.


### 29. Какой метод HTTP является (не)изменяемым?
+ HTTP метод называется неизменяемым, если он на один и тот же запрос всегда возвращает одинаковый результат. 
HTTP методы `GET`, `PUT`, `DELETE`, `HEAD` и `OPTIONS` являются неизменяемыми, поэтому необходимо реализовывать 
приложение так, чтобы эти методы возвращали одинаковый результат постоянно.

    Эти методы должны быть идемпотентными («idempotence») в том смысле, что повторное (более одного раза) выполнение
запросов с помощью этих методов будет иметь тот же эффект, что и однократное выполнение.

+ К изменяемым методам относится метод `POST`, который и используется для реализации чего-либо, что изменяется при каждом запросе.

К примеру, для доступа к статической HTML странице используется метод `GET`, т.к. он всегда возвращает одинаковый результат. 
При необходимости сохранять какую-либо информацию, например в базе данных, нужно использовать `POST` метод.
Неизменяемые методы так же известны как безопасные методы и нет необходимости заботиться о повторяющихся 
запросах от клиента для этих методов.

### 30. Почему HttpServlet класс объявлен как абстрактный?
Класс `HTTPServlet` объявлен как абстрактный, т.к. он предоставляет лишь общую реализацию сервлета для HTTP протокола. 
Реализация ключевых методов `doGet()` и `doPost()`, содержащих основную бизнес-логику перекладывается на разработчика 
и по умолчанию возвращает `HTTP 405 Method Not Implemented error`.

### 31. В чем разница между методами GET и POST?

32. Что такое MIME-тип?

33. Назовите преимущества Servlet над CGI?

34. Каковы наиболее распространенные задачи выполняются в Servlet контейнере?

35. В чем разница между PrintWriter и ServletOutputStream?

36. Можем ли мы получить PrintWriter и ServletOutputStream одновременно в сервлете?

37. Расскажите о интерфейсе SingleThreadModel.

38. Какие существуют атрибуты у сервлетов и какая сфера их применения?

39. Почему необходимо переопределить только init() метод без аргументов?

40. Что означает URL encoding? Зачем нужны методы java.net.URLEncoder.encode() и decode()?

41. Зачем нужны и чем отличаются методы encodeUrl() и encodeRedirectUrl()?

42. Какие различные методы управления сессией в сервлетах вы знаете?

43. Что означает URL Rewriting?

44. Как применяются Cookies в сервлетах?

45. Как уведомить объект в сессии, что сессия недействительна или закончилась?

46. Какой существует эффективный способ удостоверится, что все сервлеты доступны только для пользователя с валидной сессией?

47. Как мы можем обеспечить transport layer security для нашего веб приложения?

48. Как организовать подключение к базе данных и обеспечить логирование log4j в сервлете?

49. Какие важные особенности существуют в Servlet 3?

50. Каковы различные способы аутентификации сервлета?

51. Написать сервлет, реализующий загрузку файла на сервер? 

## Hibernate

[1. Что такое ORM?](#1-Что-такое-ORM)

[2. Опиши, как конфигурируется Hibernate. Рассказать про hibernate.cfg.xml и про mapping.](#2-Опиши-как-конфигурируется-Hibernate-Рассказать-про-hibernatecfgxml-и-про-mapping)

[3. Жизненный цикл Entity?](#3-Жизненный-цикл-Entity)

[4. Зачем нужен класс SessionFactory? Является ли он потокобезопасным?](#4-Зачем-нужен-класс-SessionFactory-Является-ли-он-потокобезопасным)

[5. Зачем нужен класс Session? Является ли он потокобезопасным?](#5-Зачем-нужен-класс-Session-Является-ли-он-потокобезопасным)

[6. В чем отличие методов Session.get Session.load?](#6-В-чем-отличие-методов-Sessionget-Sessionload)

[7. Расскажите про методы flush commit.](#7-Расскажите-про-методы-flush-commit)

[8. В чем отличие метода save от saveOrUpdate и merge?](#8-В-чем-отличие-метода-save-от-saveOrUpdate-и-merge)

[9. Расскажите процесс создания, редактирования, чтения и удаления данных через Hibernate.](#9-Расскажите-процесс-создания-редактирования-чтения-и-удаления-данных-через-Hibernate)

[10. Как осуществляется иерархия наследования в Hibernate? Рассказать про три стратегии наследования.](#10-Как-осуществляется-иерархия-наследования-в-Hibernate-Рассказать-про-три-стратегии-наследования)

[11. Можно ли создать собственный тип данных?](#11-Можно-ли-создать-собственный-тип-данных)

[12. Какие коллекции поддерживаются на уровне mapping?](#12-Какие-коллекции-поддерживаются-на-уровне-mapping)

[13. Зачем нужен класс Transactional?](#13-Зачем-нужен-класс-Transactional)

[14. Расскажите про уровни изоляции? Какие уровни поддерживаются в hibernate? Как их устанавливать?](#14-Расскажите-про-уровни-изоляции-Какие-уровни-поддерживаются-в-hibernate-Как-их-устанавливать)

[15. Что такое OplimisticLock? Расскажите стратегии создания через version, timestamp.](#15-Что-такое-OplimisticLock-Расскажите-стратегии-создания-через-version-timestamp)

[16. Расскажите про стратегии извлечения данных urgy, lazy?](#16-Расскажите-про-стратегии-извлечения-данных-urgy-lazy)

[17. Что такое объект Proxy? С чем связана ошибка LazyInitializationException? Как ее избежать?](#17-Что-такое-объект-Proxy-С-чем-связана-ошибка-LazyInitializationException-Как-ее-избежать)

[18. HQL. Расскажи основные элементы синтаксиса HQL? Простой запрос, запрос join? Создания объекта через конструтор.](#18-HQL-Расскажи-основные-элементы-синтаксиса-HQL-Простой-запрос-запрос-join-Создания-объекта-через-конструтор)

[19. Расскажите про уровни кешей в hibernate?](#19-Расскажите-про-уровни-кешей-в-hibernate)

[20. Что такое StatelessSessionFactory? Зачем он нужен, где он используется?](#20-Что-такое-StatelessSessionFactory-Зачем-он-нужен-где-он-используется)

[21. Зачем нужен решим read-only?](#21-Зачем-нужен-решим-read-only)

## 1. Что такое ORM?

ORM — прослойка между базой данных и кодом который пишет программист, которая позволяет созданые в программе объекты складывать/получать в/из бд.
(ORM (Object-Relational Mapping - объектно-реляционное отображение или преобразование) — технология программирования, 
которая связывает базы данных с концепциями объектно-ориентированных языков программирования, 
создавая «виртуальную объектную базу данных» "Wiki")

[к оглавлению](#Hibernate)

## 2. Опиши как конфигурируется Hibernate Рассказать про hibernatecfgxml и про mapping?

Существует четыре способа конфигурации работы с Hibernate:
+ используя аннотации;
+ hibernate.cfg.xml;
+ hibernate.properties;
+ persistence.xml.

Самый частый способ конфигурации : через аннотации и файл persistence.xml, что касается файлов hibernate.properties 
и hibernate.cfg.xml, то hibernate.cfg.xml главнее (если в приложение есть оба файла, то принимаются настройки из файла 
hibernate.cfg.xml). Конфигурация аннотациями, хоть и удобна, но не всегда возможна, к примеру, если для разных баз 
данных или для разных ситуаций вы хотите иметь разные конфигурацию сущностей, то следует использовать xml файлы конфигураций.

Файл конфигурации Hibernate содержит в себе данные о базе данных и необходим для инициализации SessionFactory. 
В .xml файле необходимо указать вендора базы данных или JNDI ресурсы, а так же информацию об используемом диалекте, 
что поможет hibernate выбрать режим работы с конкретной базой данных.

Файл отображения (mapping file) используется для связи entity бинов и колонок в таблице базы данных. 
В случаях, когда не используются аннотации JPA, файл отображения .xml может быть полезен 
(например при использовании сторонних библиотек).

Свойства и описание  	
*hibernate.dialect - Это свойство заставляет Hibernate генерировать соответствующий SQL для выбранной базы данных.  
*hibernate.connection.driver_class - Класс драйвера JDBC.  
*hibernate.connection.url - URL JDBC для экземпляра базы данных.  
*hibernate.connection.username - Имя пользователя базы данных.  
*hibernate.connection.password - Пароль базы данных.  

[к оглавлению](#Hibernate)

## 3. Жизненный цикл Entity?
 
![2016-07-11_13-38-11-1024x551.png](2016-07-11_13-38-11-1024x551.png)
 
Объект-сущность может находиться в одном из 3-х состояний (статусов):

+ transient object. Объекты в данном статусе — это заполненные экземпляры классов-сущностей. Могут быть сохранены в БД. Не присоединены к сессии. Поле Id не должно быть заполнено, иначе объект имеет статус detached ;
+ persistent object. Объект в данном статусе — так называемая хранимая сущность, которая присоединена к конкретной сессии. Только в этом статусе объект взаимодействует с базой данных. При работе с объектом данного типа в рамках транзакции все изменения объекта записываются в базу;
+ detached object. Объект в данном статусе — это объект, отсоединённый от сессии, может существовать или не существовать в БД.

[к оглавлению](#Hibernate)

## 4. Зачем нужен класс SessionFactory Является ли он потокобезопасным?

Именно из объекта SessionFactory мы получаем объекты типа Session. На все приложение существует только одна 
SessionFactory и она инициализируеться вместе со стартом приложения. SessionFactory кэширует мета-дату и SQL запросы, 
которые часто используются приложением во время работы. Так же оно кэширует информацию, 
которая была получена в одной из транзакций и может быть использована и в других транзакциях.

Обьект SessionFactory можно получить следующим обращением:
```java
SessionFactory sessionFactory = configuration.buildSessionFactory();
```

Т.к. объект SessionFactory immutable (неизменяемый), то да, он потокобезопасный. 
Множество потоков может обращаться к одному объекту одновременно.

[к оглавлению](#Hibernate)

## 5. Зачем нужен класс Session Является ли он потокобезопасным?

Сессия используется для получения физического соединения с базой данных. Объект Session является легким и предназначен для реализации каждый раз, когда необходимо взаимодействие с базой данных. Постоянные объекты сохраняются и извлекаются через объект Session.

Объекты сеанса не должны оставаться открытыми в течение длительного времени, потому что они обычно не являются потокобезопасными, и их следует создавать и уничтожать по мере необходимости.

Session — это основной интерфейс, который отвечает за связь с базой данных. Так же, он помогает создавать объекты 
запросов для получение персистентных объектов. (персистентный объект — объект который уже находится в базе данных; 
объект запроса — объект который получается когда мы получаем результат запроса в базу данных, 
именно с ним работает приложение). 

Обьект Session можно получить из SessionFactory:
```java
Session session = sessionFactory.openSession();
```

Роль интерфейса Session:
+ является оберткой для jdbc подключения к базе данных; 
+ является фабрикой для транзакций (согласно официальной документации transaction — аllows the application to define units of work, 
что , по сути, означает что транзакция определяет границы операций связанных с базой данных).
+ является хранителем обязательного кэша первого уровня.

Жизненный цикл объекта session связан с началом и окончанием транзакции. 
Этот объект предоставляет методы для CRUD (create, read, update, delete) операций для объекта персистентности. 
С помощью этого экземпляра можно выполнять HQL, SQL запросы и задавать критерии выборки.

Объект Hibernate Session не является потокобезопасным. 
Каждый поток должен иметь свой собственный объект Session и закрывать его по окончанию.

[к оглавлению](#Hibernate)

## 6. В чем отличие методов Sessionget Sessionload?

Hibernate session обладает различными методами для загрузки данных из базы данных. 
Наиболее часто используемые методы для этого — get() и load().

+ get() загружает данные сразу при вызове, в то время как load() использует прокси объект и загружает данные только тогда, 
когда это требуется на самом деле. В этом плане load() имеет преимущество в плане ленивой загрузки данных.
+ load() бросает исключение, когда данные не найдены. 
Поэтому его нужно использовать только при уверенности в существовании данных.
+ Нужно использовать метод get(), если необходимо удостовериться в наличии данных в БД.
+ В случае обращение к несуществующему объекту, метод get(); вернет null. 
В случае нахождения объект, метод get(); вернет сам объект и запрос в базу данных будет произведен немедленно.

[к оглавлению](#Hibernate)

## 7. Расскажите про методы flush commit?

В руководстве Hibernate вы можете увидеть этот пример
```java
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

for (int i = 0; i < 100000; i++) {
    Customer customer = new Customer(...);
    session.save(customer);
    if (i % 20 == 0) { // 20, same as the JDBC batch size
        // flush a batch of inserts and release memory:
        session.flush();
        session.clear();
    }
}

tx.commit();
session.close();
```
Без вызова метода flush ваш кэш первого уровня выдаст OutOfMemoryException

+ flush() синхронизирует вашу базу данных с текущим состоянием объекта/объектов, хранящихся в памяти, 
но не совершает транзакцию. 
+ если вы получите какое-либо исключение после вызова flush(), то транзакция будет отменена. 
+ Вы можете синхронизировать свою базу данных с небольшими фрагментами данных, используя flush(), вместо того, 
чтобы делать большие данные одновременно с помощью commit() и столкнуться с риском получить Исключение из памяти.
+ commit() сделает данные, хранящиеся в базе данных постоянными. 
Вы не можете отменить свою транзакцию после успешного завершения commit()

[к оглавлению](#Hibernate)

## 8. В чем отличие метода save от saveOrUpdate и merge?

Любой объект-сущность можно переводить из одного статуса в другой. Для этого в интерфейсе Session существуют следующие методы:

+ persist(Object) — преобразует объект из transient в persistent, то есть присоединяет к сессии и сохраняет в БД. Однако, если мы присвоим значение полю Id объекта, то получим PersistentObjectException — Hibernate посчитает, что объект detached, т. е. существует в БД. При сохранении метод persist() сразу выполняет insert, не делая select.
+ merge(Object) — преобразует объект из transient или detached в persistent. Если из transient, то работает аналогично persist() (генерирует для объекта новый Id, даже если он задан), если из detached — загружает объект из БД, присоединяет к сессии, а при сохранении выполняет запрос update
+ replicate(Object, ReplicationMode) — преобразует объект из detached в persistent, при этом у объекта обязательно должен быть заранее установлен Id. Данный метод предназначен для сохранения в БД объекта с заданным Id, чего не позволяют сделать persist() и merge(). Если объект с данным Id уже существует в БД, то поведение определяется согласно правилу из перечисления org.hibernate.ReplicationMode:
*ReplicationMode.IGNORE — ничего не меняется в базе.  
*ReplicationMode.OVERWRITE — объект сохраняется в базу вместо существующего.  
*ReplicationMode.LATEST_VERSION — в базе сохраняется объект с последней версией.  
*ReplicationMode.EXCEPTION — генерирует исключение.  
+ delete(Object) — удаляет объект из БД, иными словами, преобразует persistent в transient. Object может быть в любом статусе, главное, чтобы был установлен Id.
+ save(Object) — сохраняет объект в БД, генерируя новый Id, даже если он установлен. Object может быть в статусе transient или detached
+ update(Object) — обновляет объект в БД, преобразуя его в persistent (Object в статусе detached)
+ saveOrUpdate(Object) — вызывает save() или update()
+ refresh(Object) — обновляет detached-объект, выполнив select к БД, и преобразует его в persistent
+ get(Object.class, id) — получает из БД объект класса-сущности с определённым Id в статусе persistent

Объект Session кэширует у себя загруженные объекты; при загрузке объекта из БД в первую очередь проверяется кэш. Для того, чтобы удалить объект из кэша и отсоединить от сессии, используется session.evict(Object). Метод session.clear() применит evict() ко всем объектам в сессии.

[к оглавлению](#Hibernate)

## 9. Расскажите процесс создания редактирования чтения и удаления данных через Hibernate?

new->persist->marge->remove

```java
/* Method to  READ all the employees */
   public void listEmployees( ){
      Session session = factory.openSession();
      Transaction tx = null;
      
      try {
         tx = session.beginTransaction();
         List employees = session.createQuery("FROM Employee").list(); 
         for (Iterator iterator = employees.iterator(); iterator.hasNext();){
            Employee employee = (Employee) iterator.next(); 
            System.out.print("First Name: " + employee.getFirstName()); 
            System.out.print("  Last Name: " + employee.getLastName()); 
            System.out.println("  Salary: " + employee.getSalary()); 
         }
         tx.commit();
      } catch (HibernateException e) {
         if (tx!=null) tx.rollback();
         e.printStackTrace(); 
      } finally {
         session.close(); 
      }
   }
```

[к оглавлению](#Hibernate)

## 10. Как осуществляется иерархия наследования в Hibernate Рассказать про три стратегии наследования?

SQL не понимает наследование типов и не поддерживает его.

Всего таких стратегий 4:
+ Использовать одну таблицу для каждого класса и полиморфное поведение по умолчанию.
+ Одна таблица для каждого конкретного класса, с полным исключением полиморфизма и отношений 
наследования из схемы SQL (для полиморфного поведения во время выполнения будут использоваться UNION-запросы)
+ Единая таблица для всей иерархии классов. Возможна только за счет денормализации схемы SQL. 
Определять суперкласс и подклассы будет возможно посредством различия строк.
+ Одна таблица для каждого подкласса, где отношение “is a” представлено в виде «has a», 
т.е. – связь по внешнему ключу с использованием JOIN.

[https://habr.com/ru/post/337488/](https://habr.com/ru/post/337488/)

[к оглавлению](#Hibernate)

## 11. Можно ли создать собственный тип данных?

[Пользовательские типы в Hibernate](https://easyjava.ru/data/hibernate/polzovatelskie-tipy-v-hibernate/)

[к оглавлению](#Hibernate)

## 12. Какие коллекции поддерживаются на уровне mapping?

+ Bag
+ Set
+ List
+ Array
+ Map

Своей реализации тип коллекции Bag очень напоминает Set, разница состоит в том, что Bag может хранить повторяющиеся значения. 
Bag хранит непроиндексированный список элементов. Большинство таблиц в базе данных имеют индексы отображающие положение 
элемента данных один относительно другого, данные индексы имеют представление в таблице в виде отдельной колонки. 
При объектно-реляционном маппинге, значения колонки индексов мапится на индекс в Array, на индекс в List или на key в Map. 
Если вам надо получить коллекцию объектов не содержащих данные индексы, то вы можете воспользоваться коллекциями типа Bag или Set 
(коллекции содержат данные в неотсортированном виде, но могут быть отсортированы согласно запросу).

[к оглавлению](#Hibernate)

## 13. Зачем нужен класс Transactional?

*Transaction (org.hibernate.Transaction)* — однопоточный короткоживущий объект, используемый для атомарных операций. 
Это абстракция приложения от основных JDBC или JTA транзакций. org.hibernate.Session может занимать 
несколько org.hibernate.Transaction в определенных случаях.

Вместо вызовов session.openTransaction() и session.commit() используется аннотация @Transactional

[Hibernate. Основные принципы работы с сессиями и транзакциями](https://habr.com/ru/post/271115/)

[к оглавлению](#Hibernate)

## 14. Расскажите про уровни изоляции Какие уровни поддерживаются в hibernate Как их устанавливать?

Как соотносятся Lock и уровни изоляции

Уровень изоляции транзакций (transaction isolation level) - относится к чтению данных, но не к записи данных;
Lock относится к доступу к данным (то есть затрагивает и чтение и запись и модификацию);
Можно сказать так, что механизм Lock обеспечивает работоспособность различных уровней изоляции данных, в самом тупом примере: если у вас стоит уровень изоляции READ_COMMITTED, то вставка произведенная параллельной сессией будет локирована на запись пока сессия не выдаст commit(), но лок на чтение будет открыт сразу при запросе вашего select, а при REPEATABLE_READ оба лока (на чтение и запись) будут стоять до commit() - соответственно ваш select увидит результаты модификации только после коммита.
Каким способом в Hibernate можно указать требуемый уровень изоляции транзакции для конкретной транзакции?

Вообще это не сильно здорово. Уровень изоляции транзакций это принадлежность коннекта к БД, соответственно фактически изменение уровня изоляции равносильно переконнекту к БД, а насколько это дорогая операция вы сами можете оценить исходя из имеющейся у вас ситуации.

Тем не менее, если вы таки решили менять перед каждой транзакцией уровень изоляции транзакций, то самый простой способ это отправить в СУБД raw SQL query (любой ORM это поддерживает), типа:

```sql
ALTER SESSION SET ISOLATION_LEVEL SERIALIZABLE
```

Это 4 уровня изоляции основных транзакций:
+ читать без фиксации - представьте две транзакции, «A» и «B».
Во-первых, «А» записывает данные в одну таблицу, не совершая транзакции.
После этого «B» считывает незафиксированные данные и работает над ними.
Но при совершении транзакции A возникает некоторая ошибка, и все изменения откатываются.
В этом случае «B» продолжает работать с незафиксированными данными транзакцией «A». Этот режим очень быстрый, но может ввести
много проблем с непротиворечивостью данных.
+ чтение зафиксировано - мы по-прежнему используем тот же сценарий, что и для чтения без фиксации, но зафиксированные данные заблокированы.
Это означает, что «B» не может видеть незавершенные данные из транзакции «A». «B» может увидеть это только тогда, когда «A» зафиксирует свою транзакцию.
+ повторяемое чтение - этот уровень изоляции способствует чтению тех же данных, даже если данные были изменены.
Мы продолжаем работать с нашими сделками «А» и «B». Сначала «B» выполняет запрос SELECT и блокирует выбранные строки.
После этого «A» выполняет запрос INSERT. «B» выполняет новый запрос SELECT с теми же условиями, что и первый.
«B» теперь будет видеть те же результаты, что и раньше (второй SELECT должен быть выполнен в той же транзакции, что и первый).
+ сериализуемый - этот уровень возникает, когда наша транзакция «B» считывает данные и блокирует всю таблицу данных.
 Это означает, что другая транзакция не может изменить данные в этой таблице.
 В отличие от чтения без фиксации, этот способ является наиболее безопасным. Но с другой стороны, это и самое медленное решение.

Hibernate запускает транзакции, вызывая методы getTransaction () (реализация JPA) или beginTransaction () (Session Hibernate).
В соответствии с используемым механизмом сохранения транзакция может быть экземпляром javax.persistence.EntityTransaction (для JPA) или org.hibernate.Transaction (для сеанса Hibernate).
Обе транзакции начинаются с помощью метода begin (), откатываются с помощью метода rollback () и фиксируются с помощью вызова commit ().

Чтобы настроить уровень изоляции транзакций в Hibernate, нам нужно изменить свойство, называемое * hibernate.connection.isolation *.
Это свойство может принимать одну из следующих записей:
+1 (читать без ответа)
+ 2 (прочитано как совершено)
+ 4 (повторяемое чтение)
+ 8 (сериализуемый)

Обычно уровень изоляции устанавливается на уровне java.sql.Connection с помощью метода setTransactionIsolation (int level).
Уровень, переданный в параметре, должен быть одним из констант Connection:

+ Connection.TRANSACTION_READ_UNCOMMITTED, 
+ Connection.TRANSACTION_READ_COMMITTED, 
+ Connection.TRANSACTION_REPEATABLE_READ 
+ Connection.TRANSACTION_SERIALIZABLE.

[к оглавлению](#Hibernate)

## 15. Что такое OplimisticLock Расскажите стратегии создания через version timestamp?

очень важно правильно управлять одновременным доступом к базе данных.
Мы должны иметь возможность обрабатывать несколько транзакций эффективным и, что самое главное, безошибочным способом.
Для этого мы можем использовать оптимистичный механизм блокировки.

Чтобы использовать оптимистическую блокировку, * нам нужен объект, включающий свойство с аннотацией @Version. *
При его использовании каждая транзакция, считывающая данные, содержит значение свойства версии.
Прежде чем транзакция хочет выполнить обновление, она снова проверяет свойство версии.
Если за это время значение изменилось, генерируется исключение OptimisticLockException.
В противном случае транзакция фиксирует обновление и увеличивает значение свойства версии.

Как мы уже говорили ранее, оптимистическая блокировка основана на обнаружении изменений в сущностях путем проверки их атрибута версии *.
Если происходит какое-либо одновременное обновление, возникает исключение OptmisticLockException. После этого мы можем повторить попытку обновления данных.

Мы можем представить, что этот механизм подходит для приложений, которые выполняют гораздо больше операций чтения, чем обновления или удаления.
Более того, это полезно в ситуациях, когда сущности необходимо отсоединить на некоторое время, а блокировки нельзя удерживать.

* Напротив, механизм пессимистической блокировки включает блокировку объектов на уровне базы данных. *

Каждая транзакция может получить блокировку данных. Пока он удерживает блокировку, транзакция не может читать,
удалить или обновить заблокированные данные. Мы можем предположить, что использование пессимистической блокировки может привести к тупикам.
Однако он обеспечивает большую целостность данных, чем оптимистическая блокировка.

Атрибуты версии - это свойства с аннотацией @Version. * Они необходимы для включения оптимистической блокировки. *

[https://www.baeldung.com/jpa-optimistic-locking](https://www.baeldung.com/jpa-optimistic-locking) 

[к оглавлению](#Hibernate)

## 16. Расскажите про стратегии извлечения данных urgy lazy?

+ Eager Loading is a design pattern in which data initialization occurs on the spot. Загружаются все данные по цепочке.
+ Lazy Loading is a design pattern which is used to defer initialization of an object as long as it's possible. 
Данные подгружаются при обращении.

[к оглавлению](#Hibernate)

## 17. Что такое объект Proxy С чем связана ошибка LazyInitializationException Как ее избежать?

Hibernate использует прокси объект для поддержки отложенной загрузки. 
Обычно при загрузке данных из таблицы Hibernate не загружает все отображенные (замаппинные) объекты. 
Как только вы ссылаетесь на дочерний объект или ищите объект с помощью геттера, если связанная сущность не находиться 
в кэше сессии, то прокси код перейдет к базе данных для загрузки связанной сущности. 
Для этого используется javassist, чтобы эффективно и динамически создавать реализации подклассов ваших entity объектов.

Hibernate поддерживает ленивую инициализацию используя proxy объекты и выполняет запросы к базе данных только 
по необходимости.

fetch = FetchType.LAZY это значит, что хибернейт не будет инициализировать эти поля пока вы к ним не обратитесь. 
Но т.к. вы обращаетесь к этим полям за пределами транзакционных методов, он не может это сделать и выкидывает ошибку.
Чтобы этого избежать надо, что метод, который обращается к этим полям был с аннотацей Transactional

Или как предложили в комментариях: Hibernate.initialize(owner.getBooks());

Это хак, но он заставит хибернейт инициировать коллекцию. НО! 
Возможно это не всегда надо и тогда надо выбрать первый вариант и отталкиваться от здравого смысла, смотреть, 
где надо навешивать аннотацию, а где нет.

[к оглавлению](#Hibernate)

## 18. HQL Расскажи основные элементы синтаксиса HQL Простой запрос запрос join Создания объекта через конструтор

Hibernate Framework поставляется с мощным объектно-ориентированным языком запросов — Hibernate Query Language (HQL). 
Он очень похож на SQL, за исключением, что в нем используются объекты вместо имен таблиц, что делает язык ближе к объектно-ориентированному программированию.

HQL является регистронезависимым, кроме использования в запросах имен java переменных и классов, где он подчиняется правилам Java. 
Например, SelECt то же самое, что и select, но ru.javastudy.MyClass отличен от  ru.javastudy.MyCLASS. Запросы HQL кэшируются (это как плюс так и минус).

For example, if we have these two queries:
```sql
FROM Employee emp
JOIN emp.department dep

and

FROM Employee emp
JOIN FETCH emp.department dep
```

In this two queries, you are using JOIN to query all employees that have at least one department associated.
But, the difference is: in the first query you are returning only the Employes for the Hibernate. 
In the second query, you are returning the Employes and all Departments associated.
So, if you use the second query, you will not need to do a new query to hit the database again to see the Departments of each Employee.
You can use the second query when you are sure that you will need the Department of each Employee. 
If you not need the Department, use the first query.

[к оглавлению](#Hibernate)

## 19. Расскажите про уровни кешей в hibernate?

Hibernate использует кэширование, чтобы сделать наше приложение быстрее. 
Кэш Hibernate может быть очень полезным в получении высокой производительности приложения при правильном использовании. 
Идея кэширования заключается в сокращении количества запросов к базе данных.

Кэш первого уровня Hibernate связан с объектом Session. 
Кэш первого уровня у Hibernate  включен по умолчанию и не существует никакого способа, чтобы его отключить. 
Однако Hibernate предоставляет методы, с помощью которых мы можем удалить выбранные объекты из кэша или полностью очистить кэш.
Любой объект закэшированный в session не будет виден другим объектам session. После закрытия объекта сессии все кэшированные 
объекты будут потеряны.

[к оглавлению](#Hibernate)

## 20. Что такое StatelessSessionFactory Зачем он нужен где он используется?

StatelessSession – командно-ориентированный API, предоставляемый Hibernate. 
Используйте его для потоковой передачи данных в базу и из нее в форме отсоединенных (detached) объектов. 
StatelessSession не имеет ассоциированного persistence-контекста и не предоставляет большую часть высокоуровневой семантики. 

```java
StatelessSession session = sessionFactory.openStatelessSession();
Transaction tx = session.beginTransaction();
   
ScrollableResults customers = session.getNamedQuery("GetCustomers")
    .scroll(ScrollMode.FORWARD_ONLY);
while ( customers.next() ) {
    Customer customer = (Customer) customers.get(0);
    customer.updateStuff(...);
    session.update(customer);
}
   
tx.commit();
session.close();
```

Объекты Customer, возвращенные запросом, будут отсоединены немедленно. Они не будут ассоциированы с каким-либо контекстом персистентности.

Операции insert(), update(), и delete(), определенные в интерфейсе StatelessSession работают напрямую со строками таблиц. Они приводят к немедленному выполнению соотвествующих SQL-операций, т.к имеют другую семантику, нежели методы save(), saveOrUpdate(), и delete(), определенные в интерфейсе Session.

[к оглавлению](#Hibernate)

## 21. Зачем нужен решим read only?

На самом деле у вас могут быть причины отмечать транзакции как доступные только для чтения.

+ Транзакции для чтения могут выглядеть действительно странно, и часто люди в этом случае не отмечают методы для транзакций.
Но JDBC все равно создаст транзакцию, просто она будет работать в autocommit = true
если другой параметр не был задан явно.
+ Но нет гарантии, что ваш метод не записывается в базу данных.
Если вы пометите метод как @Transactional (readonly = true), Spring установит транзакцию JDBC в режим только для чтения,
таким образом, вы будете диктовать, действительно ли возможно производить запись в БД в рамках этой транзакции.
Если ваша архитектура громоздка и некоторые члены команды могут решить поместить запрос на изменение там, где это не ожидается,
этот флаг укажет вам на проблемное место.
+ Также БД могут оптимизировать транзакции только для чтения, но это, конечно, зависит от БД.
Например. MySQL добавил поддержку этого только в InnoDB, начиная с версии 5.6.4.
+ Если вы используете не JDBC напрямую, а ORM, это может быть проблематично.
Например, сообщество Hibernate утверждает, что работа вне транзакции может вызвать непредсказуемое поведение.
Это связано с тем, что Hibernate откроет транзакцию, но не закроет ее самостоятельно, поэтому соединение будет возвращено
в пул соединений, при этом транзакция не зафиксирована. Что тогда происходит?
JDBC хранит молчание, поэтому это зависит от реализации (MySQL откатывает транзакцию, Oracle ее фиксирует).
Это также можно настроить на уровне пула подключений (например, C3P0 дает вам такую ​​возможность, откат по умолчанию).
+ Еще одна вещь, когда дело доходит до Hibernate, Spring устанавливает FlushMode в MANUAL в случае транзакций только для чтения,
что приводит к другим оптимизациям, таким как отсутствие необходимости в грязных проверках.
+ Возможно, вы захотите переопределить или явно установить уровень изоляции транзакции.
Это также влияет на транзакции чтения, поскольку вы хотите или не хотите читать незафиксированные изменения,
подвергаться фантомному чтению и т. д.

[к оглавлению](#Hibernate)

## Туториалы:

Hibernate Tutorial https://www.tutorialspoint.com/hibernate/index.htm
 
Hibernate ORM http://hibernate.org/orm/documentation/5.4/

https://ru.wikipedia.org/wiki/Hibernate_(%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0)

# Questions:
## 1. Чем отличается процесс от потока?
В ОС за выполнение задач отвечает процессор. Чем больше процессоров имеет компьютер, тем больше задач может одновременно выполнить компьютер.
Один процессор может одновременно выполнять только одну задачу. Задача выполняемая процессором называется процесс. То есть если в вашем компьютере два процессора, то он может выполнять два процесса параллельно. Процессы не могут обмениваться между собой данными. Это не зависимые элементы.

Виртуальная машина позволяет программистам создавать такие задачи, которые могут выполняться в многозадачном режиме. То есть часть задачи выполнится, а потом переключится на другую часть задачи и так пока все инструкции в этих задачах не будут выполнены. 

Такие задачи называются потоками исполнения или нить исполнения (от английского слова Thread). Как я уже писал процессы не могут взаимодействовать между собой и один процессор может иметь только один процесс. В свою очередь нити исполнения - это абстракция над процессом исполнения. Нитей исполнения можно создать сколько угодно. Так же нити могут обмениваться между собой данными.

Если сказать проще, процессор имеет только один процесс, а сам процесс может иметь множество нитей.

## 2. Каким образом можно создать поток?
+ Создать потомка класса `Thread` и переопределить его метод `run()`;
    ```java
    public class HelloThread extends Thread {
        
        @Override
        public void run() {
            System.out.println("Hello from a thread!");
        }
    
        public static void main(String args[]) {
            (new HelloThread()).start();
        }
    }
    ```
+ Создать объект класса `Thread`, передав ему в конструкторе экземпляр класса, реализующего интерфейс `Runnable`. 
Этот интерфейс содержит метод `run()`, который будет выполняться в новом потоке. Поток закончит выполнение, 
когда завершится его метод `run()`.
    ```java
    public class HelloRunnable implements Runnable {
        
        @Override
        public void run() {
            System.out.println("Hello from a thread!");
        }
    
        public static void main(String args[]) {
            (new Thread(new HelloRunnable())).start();
        }  
    }
    ```

+ Вызвать метод `submit()` у экземпляра класса реализующего интерфейс `ExecutorService`, передав ему в качестве 
параметра экземпляр класса, реализующего интерфейс `Runnable` или `Callable` 
(содержит метод `call()`, в котором описывается логика выполнения).

    ```java
    public class CallableExample {
     
      public static class WordLengthCallable implements Callable {
          private String word;
          public WordLengthCallable(String word) {
              this.word = word;
          }
          public Integer call() {
              return Integer.valueOf(word.length());
          }
      }
     
      public static void main(String args[]) throws Exception {
          ExecutorService pool = Executors.newFixedThreadPool(3);
          Set<Future<Integer>> set = new HashSet<Future<Integer>>();
          for (String word: args) {
              Callable<Integer> callable = new WordLengthCallable(word);
              Future<Integer> future = pool.submit(callable);
              set.add(future);
          }
          int sum = 0;
          for (Future<Integer> future : set) {
              sum += future.get();
          }
          System.out.printf("The sum of lengths is %s%n", sum);
          System.exit(sum);
      }
    }
    ```

https://docs.oracle.com/javase/tutorial/essential/concurrency/runthread.html
## 3. Как работают методы sleep, yield, wait, notify и notifyAll?
+ `sleep` - усыпляет поток некоторое время, не освобождая lock объект (локи\мониторы\ресурсы).
+ `wait` - усыпляет поток, освобождает lock объект.
+ `notify` - будит последний стоящий в очереди поток.
+ `notifyAll` - будит все стоящие в очереди объекты.
+ `yield` - принудительно передает квант времени следующему потоку, т.е. уступает очередь потокам.

Методы `wait`, `notify` и `notifyAll` класса `Object` позволяют работать с синхронизацией и lock-ами (мониторами) 
на более низком уровне. 
см. Effective Java и [пример Петра](https://www.youtube.com/watch?v=6pwM3p2pbic&list=PLW8mAQ8rFUhKFkuXDTb3PT1GKz0T-lCv6&index=13)
## 4. Объясните следующие термины: монитор, мьютекс, критическая секция.
В многопоточном приложении двум или нескольким потокам может потребоваться одновременный доступ к общему ресурсу, 
что приводит к неожиданному поведению. Примерами таких общих ресурсов являются структуры данных, 
устройства ввода-вывода, файлы и сетевые подключения.
 
**Критическая секция** - часть исполняемого кода программы, которая обращается к общему ресурсу 
(данным или устройству), который не должен быть одновременно использован более чем одним потоком выполнения. 
При нахождении в критической секции двух или более потоков возникает состояние «гонки». 
Чтобы избежать состояния гонки, нужно синхронизировать доступ к критическому разделу.

**Мьютекс** (MUTual EXclusion или взаимное исключение) - это самый простой тип синхронизатора потоков/нитей, который 
гарантирует, что только один поток может одновременно выполнять критический раздел компьютерной программы.
Мьютекс может принимать два состояния – занят и свободен. 

Удобно представлять мьютекс как id захватившего его объекта. Если этот id равен 0 – ресурс свободен. 
Если не 0 – ресурс занят. Можно встать в очередь и ждать его освобождения.

Чтобы получить доступ к критическому разделу, поток получает мьютекс, затем обращается к критическому разделу и, 
наконец, освобождает мьютекс. Тем временем все остальные потоки блокируются до освобождения мьютекса. 
Как только поток выходит из критической секции, другой поток может войти в критическую секцию.

*Задача мьютекса* — защита объекта от доступа к нему других потоков, отличных от того, который завладел мьютексом. 
В каждый конкретный момент только один поток может владеть объектом, защищённым мьютексом. 
Если другому потоку будет нужен доступ к объекту, то этот поток блокируется до тех пор, пока мьютекс не будет освобождён.

*Цель использования мьютексов* — защита данных от повреждения в результате асинхронных изменений (состояние гонки), 
однако могут порождаться другие проблемы — например взаимная блокировка ([DeadLock](#Что-такое-DeadLock)).

Работать с мютексом в Java можно посредством монитора.
**Монитор** – это высокоуровневая надстройка над мютексом (по факту кусок кода), которая обеспечивает правильную работу с ним. 

В Java монитор реализован с помощью ключевого слова `synchronized`. 
Используется он так: любой нестатический `synchronized`-метод при своем вызове прежде всего пытается захватить монитор 
того объекта, у которого он вызван (на который он может сослаться как на `this`). Если это удалось – метод исполняется. 
Если нет – поток останавливается и ждет, пока монитор будет свободен.

Итого:

**Монитор и мьютекс – это средство обеспечения контроля за доступом к ресурсу.**

**Мьютекс синхронизирует доступ потоков к критической секции, а монитор обеспечивает правильную работу с мьютексом
посредством `synchronized`.**

*Пример из жизни: очередь в туалет, где очередь - это потоки, дверной замок - мьютекс, 
блок электронного управления замком с маячком - монитор, а туалет - критическая секция.*

Когда человек заходит в туалет, он закрывает изнутри дверь на замок.
Туалет выполняет роль объекта, доступ к которому получают несколько потоков. 
Замок на двери туалета — роль мьютекса, а очередь из людей снаружи — роль потоков.
Замок на двери — мьютекс туалета: он гарантирует, что внутри одновременно может находиться только один человек. 
Иными словами, только один поток в определенное время может работать с общими ресурсами. 
Попытки других потоков (людей) получить доступ к занятым ресурсам будут неудачными.

https://www.baeldung.com/java-mutex
https://stackoverflow.com/questions/3362303/whats-a-monitor-in-java
https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantLock.html
https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html
## 5. Как работает join()?
6. Что такое DeadLock? Приведите примеры.
7. Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.
8. Различия в интерфейсах Runnable и Callable.
9. Различя между isInterrupted(), interrupted().
10. Что происходит при вызове Thread.interrupt()?
11. Перечислите ВСЕ причины по которым может выскочить InterruptedException.
12. Назовите отличия synchronize{} и ReentrantLock.
13. Приведите наиболее существенное отличие между CountDownLatch и Barrier.
14. Отличие Thread.start() и Thread.run()?
15. Объясните ключевое слово volatile.
16. Расскажите про приоритеты потока.
17. Что такое потоки-демоны?
18. Назовите все возможные состояния потока.
19. Что такое race condition?
20. Что такое Thread Local переменная? 
21. Что такое FutureTask?
22. Что такое Thread Pool?
23. Что такое Semaphore?
24. Чем отличается submit от execute у ExecutorServices?
25. Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?
27. Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков.
28. Что такое ReadWriteLock?
29. В чём отличие Thread от FutureTask? В чём отличие Thread.interrupt() и FutureTask.cancel().
30. Расскажите про шаблон проектирования Producer Consumer.

### interested
#### youtube:
> - [Шипилев об ForkJoinPool](https://www.youtube.com/watch?v=t0dGLFtRR9c&ab_channel=JUG.ru)
#### links:
> - [Список книг и посмотреть выкладки](https://smartprogress.do/goal/382579/?lang=ru)
> - [Синхронное/Асинхронное](https://ru.stackoverflow.com/questions/445768/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D0%B5-vs-%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
> - [ForkJoinPool](https://habr.com/ru/post/565924/)
#### read:
> Вам нужно выкопать во дворе бассейн. 
> - Вы взяли лопату и копаете. Это однопоточная работа 
> - Вы пригласили друга Васю и копаете вместе, периодически задевая друг-друга лопатами. Это многопоточная работа 
> - Пока вы копаете бассейн, Вася копает канаву под водопровод. Никто никому не мешает. Это распараллеливание 
> - Вы пригласили бригаду землекопов, а сами с Васей пошли пить пиво. Когда бригада все сделает, к вам придут за деньгами. Это асинхронная работа. 
> - Количество лопат в хозяйстве - это количество ядер в системе

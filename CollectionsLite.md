## Collections Lite

#### part 2. [Collections Pro](CollectionsPro.md#collections-pro)

[1. Что такое коллекция?](#1-Что-такое-коллекция)

[2. Назовите преимущества использования коллекций?](#2-Назовите-преимущества-использования-коллекций)

[3. Какие данные могут хранить коллекции?](#3-Какие-данные-могут-хранить-коллекции)

[4. Какие есть типы коллекций? Как они характеризуются?](#4-Какие-есть-типы-коллекций-Как-они-характеризуются)

[5. Назовите основные реализации List, Set, Map?](#5-Назовите-основные-реализации-List,-Set,-Map)

[6. В чём отличие ArrayList от LinkedList?](#6-В-чём-отличие-ArrayList-от-LinkedList)

[7. В чём отличие HashSet от TreeSet?](#7-В-чём-отличие-HashSet-от-TreeSet)

[8. В чём отличие Set от Map?](#8-В-чём-отличие-Set-от-Map)

[9. Как задается порядок следования объектов в коллекции? Как отсортировать коллекцию?](#9-Как-задается-порядок-следования-объектов-в-коллекции-Как-отсортировать-коллекцию)

[10. Чем отличается Comparable от Comparator?](#10-Чем-отличается-Comparable-от-Comparator)

[11. Что такое сортировка по принципу Natural Order?](#11-Что-такое-сортировка-по-принципу-Natural-Order)

[12. Что такое equals и hashcode?](#12-Что-такое-equals-и-hashcode)

[13. Какие есть способы перебора всех элементов List?](#13-Какие-есть-способы-перебора-всех-элементов-List)

[14. Как реализован цикл foreach?](#14-Как-реализован-цикл-foreach)

[15. В чем разница между Iterator и ListIterator?](#15-В-чем-разница-между-Iterator-и-ListIterator)

[16. Как происходит удаление элементов из ArrayList?](#16-Как-происходит-удаление-элементов-из-ArrayList)

[17. Как происходит удаление элементов из LinkedList?](#17-Как-происходит-удаление-элементов-из-LinkedList)

[18. Расскажите иерархию интерфейсов Collections framework?](#18-Расскажите-иерархию-интерфейсов-Collections-framework)

[19. Назовите основные методы интерфейса Collections?](#19-Назовите-основные-методы-интерфейса-Collections)

[20. Может ли null использоваться в качестве ключа в Map?](#20-Может-ли-null-использоваться-в-качестве-ключа-в-Map)

[21. Может ли Set содержать null?](#21-Может-ли-Set-содержать-null)

[22. Как преобразовать массив строк в ArrayList?](#22-Как-преобразовать-массив-строк-в-ArrayList)

[23. Как отсортировать список в обратном порядке?](#23-Как-отсортировать-список-в-обратном-порядке)

[24. Какие реализации SortedSet вы знаете и в чем их особенность?](#24-Какие-реализации-SortedSet-вы-знаете-и-в-чем-их-особенность)

[25. В каких случаях разумно использовать массив, а не ArrayList?](#25-В-каких-случаях-разумно-использовать-массив-а-не-ArrayList)

[26. Какие коллекции синхронизированы?](#26-Какие-коллекции-синхронизированы)

## 1. Что такое коллекция?

**Коллекции** - это хранилища, поддерживающие различные способы накопения и упорядочивания объектов с целью обеспечения 
эффективного доступа к ним.

Они представляют собой реализации абстрактных структур данных, поддерживающих различные способы хранения данных, а также
операции добавления, удаления и изменения элементов. Т.е. это набор интерфейсов и реализующих их классов.

[к оглавлению](#collections-lite)

## 2. Назовите преимущества использования коллекций?

+ отсутствует необходимость следить за размерами коллекции (в отличае от массива);

+ позволяют сократить количество кода и требуют меньше усилий для реализации, т.к. в коллекциях реализовано 
много методов по добавлению, удалению, сортировке элементов и т.п.;

+ если правильно подобрать коллекцию, то можно увеличить производительность программы;

+ упрощают взаимодействие разных частей программы, т.к. являются универсальным способом хранения и передачи данных.

[к оглавлению](#collections-lite)

## 3. Какие данные могут хранить коллекции?

Коллекции могут хранить любые ссылочные типы данных.

[к оглавлению](#collections-lite)

## 4. Какие есть типы коллекций Как они характеризуются?

+ **Set** - множество неповторяющихся элементов (Здесь могут храниться только уникальные значения, нет дубликатов)

+ **Queue** (Deque) - очередь (FIFO первый вошел, первый вышел). реализует LinkedList

+ **List** - упорядоченный список (В какой последовательности данные положили, в такой они и хранятся.
Допускаются дубликаты.)

+ **Map** - карта, ассоциативный массив (Значения хранятся в виде пар ключ=значение. Каждому элементу из множества
ключей соответствует множество значений. Ключи уникальные. По ключу получаем значение. У мапы нет итератора. 
Map не наследуется от Collection.) 

Справочник по Java Collections Framework https://habr.com/ru/post/237043/

[к оглавлению](#collections-lite)

## 5. Назовите основные реализации List, Set, Map?

+ **List:** ArrayList, LinkedList

+ **Set:** HashSet, LinkedHashSat, TreeSet

+ **Map:** HashMap, LinkedHashMap, TreeMap

[к оглавлению](#collections-lite)

## 6. В чём отличие ArrayList от LinkedList?

**ArrayList - основан на динамическом массиве**, хранит свои элементы в массиве. 
(используют, если элементы чаще читаются, чем добавляются)

**+** Быстрая навигация по коллекции - осуществляется быстрый поиск элементов;

**+** меньше расходует памяти на хранение элементов;

**-** увеличение `ArrayList` происходит медленно;

**-** при вставке или удалении элемента в середину или в начало, приходится переписывать все элементы;

**LinkedList - двунаправленный список (цепочка)**, хранит элементы в объектах `Node<E>`, у которых есть ссылки на 
предыдущий и следующий элементы (используют, если элементы чаще добавляются, чем читаются) 

**+** быстрая вставка и удаление в середину списка (переписать `next` и `previous` и всё);

**-** долгий поиск в середине (нужно перебрать все элементы);

Очевидно, что плюсы одного являются минусами второго.
В среднем, сложности одинаковые, но все же `ArrayList` предпочтительнее использовать. 
`LinkedList` рекомендуется использовать, только когда преобладает удаление или вставка в начало или конец списка.

[к оглавлению](#collections-lite)

## 7. В чём отличие HashSet от TreeSet?

**Set** - множество неповторяющихся элементов.

**HashSet** хранит данные в произвольном порядке (хранит свои значения как ключи `HashMap`).

**TreeSet** хранит данные в отсортированном виде (в основе реализации бинарное красно-черное дерево).

[к оглавлению](#collections-lite)

## 8. В чём отличие Set от Map?

сет это список ключей от мапы.

[к оглавлению](#Collections-Lite)

## 9. Как задается порядок следования объектов в коллекции Как отсортировать коллекцию?

Порядок задается либо естественным следованием элементов (natural order), 
либо объектом, реализующим интерфейс сравнения `Comparator`.

Можно отсортировать с помощью интерфейса `Comparable` или интерфейса `Comparator`:
 
+ Если объекты коллекции поддерживают интерфейс `Comparable`, то через `Collections.sort(collection)`; 

+ Если нет, то у коллекции вызвать метод `sort()` и передать ему `Comparator` в качестве аргумента `collection.sort(new MyComparator())`.
Либо использовать метод `Collections.sort(collection, new MyComparator())`.

[к оглавлению](#collections-lite)

## 10. Чем отличается Comparable от Comparator?

**Comparable** - используется только для сравнения объектов класса, в котором данный интерфейс реализован. 
Т.е. интерфейс `Comparable` определяет логику сравнения объектов определенного ссылочного типа внутри своей 
реализации (по правилам разработчика). 
`Collections.sort(collection);`

**Comparator** - представляет отдельную реализацию и ее можно использовать многократно и с различными классами. 
Т.е. интерфейс `Comparator` позволяет создавать объекты, которые будут управлять процессом сравнения: 
1. при сортировках в методах `Collections.sort(collection, new MyComparator())`, `Arrays.sort(array, new MyComparator())` 
или `collection.sort(new MyComparator())`
2. при управлении порядком в отсортированных множествах `TreeSet` или отсортированных картах `TreeMap`,
 например `new TreeSet<T> (new MyComparator())`.

**Разница:**

+ `Comparable` определяет логику сравнения объектов определенного ссылочного типа внутри своей реализации 
и, если нет доступа к исходникам, ее невозможно изменить. 

+ `Comparator` позволает определить логику сравнения объектов определенного ссылочного типа вне реализации 
этого типа и эту логику можно в любой момент подменить.

*`Comparable` используется для `natural ordering`, а `Comparator` для `total ordering`.*

**Примеры:**

http://java-online.ru/blog-comparator.xhtml

https://netjs.blogspot.com/2015/10/difference-between-comparable-and-comparator-java.html

https://www.programcreek.com/2011/12/examples-to-demonstrate-comparable-vs-comparator-in-java/

[к оглавлению](#collections-lite)

## 11. Что такое сортировка по принципу Natural Order?

Некоторые классы из коробки реализуют естественный порядок `natural order` для сортировки:

+ строки - лексикографический (по алфавиту),
+ числа - числовой, знаковый или без (больше меньше),
+ дата - хронологичский (по датам),
+ файл - лексикографический по имени пути
+ boolean - false < true

Остальные классы нужно руками делать `Comparable` или `Comparator`.

[к оглавлению](#collections-lite)

## 12. Что такое equals и hashcode?

Методы, необходимые для определения равенства объектов. 

`hashcode` возвращает число, являющееся уникальным идентификатором объекта. 
Это алгоритм, который позволяет множество значений объектов сузить до какого-то натурального количества.
 
`equals` сравнивает объекты по значению их полей. 

Объекты всех коллекций в названии которых есть *Hash...* должны иметь `hashcode` и `equals`.

[к оглавлению](#collections-lite)

## 13. Какие есть способы перебора всех элементов List?

Есть список стран, его нужно перебрать
```java
List<String> countries = Arrays.asList("Russia", "Panama", "Australia");
```
+ **циклы** `for`, `while`, `foreach`

```java
for (int i = 0; i < countries.size(); i++) {
    System.out.println(countries.get(i));
}
```

```java
int i = 0;
while (i < countries.size()){
    System.out.println(countries.get(i++));
}
```

```java
for (String country : countries) {
    System.out.println(country);
}    
```

+ **итераторы** `Iterator`, `ListIterator`
```java
Iterator<String> countriesIterator = countries.iterator();
while(countriesIterator.hasNext()) {
    System.out.println(countriesIterator.next());
}
```

```java
ListIterator<String> listIterator = countries.listIterator();
//в прямом порядке
while(listIterator.hasNext()) {
    System.out.println(listIterator.next());
}
//в обратном порядке
while(listIterator.hasPrevious()) {
    System.out.println(listIterator.previous());
}    
```
Если вызвать метод `next()` итератора, указывающего на последний элемент в коллекции, 
то возникнет исключение `NoSuchElementException`. Следует это помнить и использовать метод `hasNext()` перед вызовом `next()`.

+ **функция `forEach()`** 
    
    + **`Iterable.forEach()`** можно использовать для итерации по элементам списка начиная с Java 8. 
Этот метод определен в интерфейсе Iterable и может принимать лямбда-выражения в качестве параметра.
    ```java
    countries.forEach(System.out::println);
    ```
    
    + **`Stream.forEach()`** Мы также можем преобразовать коллекцию значений в поток и получить доступ 
    к таким операциям, как `forEach()`, `map()`, или `filter()`.
    ```java
    countries.stream().forEach(
        (c) -> System.out.println(c)
    );
    ```
    
https://www.codeflow.site/ru/article/java-iterate-list    

[к оглавлению](#collections-lite)

## 14. Как реализован цикл foreach?

`foreach` реализован на основе `Iterator`, т.е. он работает для классов, реализующих интерфейс `Iterable`.

(И наоборот, если коллекция `extends` от `Iterable`, то мы можем перебирать элементы этой коллекции с помощью `foreach`)

[к оглавлению](#collections-lite)

## 15. В чем разница между Iterator и ListIterator?

`ListIterator` расширяет `Iterator`, отличия следующие:

+ `Iterator` может использоваться для перебора элементов коллекций `Set`, `List` и `Map`. 
`ListIterator` может быть использован только для перебора элементов коллекции `List`

+ `Iterator` позволяет перебирать элементы только в одном направлении, при помощи метода `next()`. 
`ListIterator` позволяет перебирать список в обоих направлениях, при помощи методов `next()` и `previous()`.

+ `ListIterator` позволяет модифицировать список, добавляя/заменяя/удаляя элементы с помощью методов `add()`, `set()`
`remove()`. Iterator не поддерживает данного функционала.

[к оглавлению](#collections-lite)

## 16. Как происходит удаление элементов из ArrayList?

Находится заданный элемент. 
Далее сдвигаются влево на один элемент все последующие (с большим индексом) элементы, а значение `size` уменьшается на 1.

Непосредственно под капотом: 
```java
System.arraycopy(es, i + 1, es, i, newSize - i)
es[size = newSize] = null;
```

[к оглавлению](#collections-lite)

## 17. Как происходит удаление элементов из LinkedList?

Заменяются ссылки `previous` и `next` у соседних элементов.

[к оглавлению](#collections-lite)

## 18. Расскажите иерархию интерфейсов Collections framework?

+ interface **`Collections`** extends **`Iterable`**.
    + interface `Set` (коллекция без дублирования)
        + `HashSet` базирующаяся на `HashMap` В качестве ключа используется добавляемый элемент, 
        а в качестве значения — объект-пустышка (new Object())
        + `LinkedHashSet` в основе лежит `LinkedHashMap`
    + interface `SortedSet` Методы: `first()`, `last()`
        + `TreeSet` (отсортированный список) содержит в себе объект `NavigableMap`.
    + interface `Queue` очередь Методы: `offer()`, `element()`, `peek()`, `poll()`, `remove()`.
    + interface `Deque` двусторонняя очередь `addFirst()`, `addLast()`, `getFist()`, `getLast()`, 
    (`push()`, `pop()` -> использовать как стек)
    + interface `List` упорядоченная коллекция (сохраняет последовательность элементов. можно получить по индексу, можно 
    повторяющиеся, можно по значению первый найденный)
    + `Vector` @deprecated реализация динамического массива объектов. Позволяет хранить любые данные, включая `null` 
    в качестве элемента
        + `Stack` - данная коллекция является расширением коллекции `Vector`. реализация стека `LIFO`.
        + `ArrayList` динамический массив, можно хранить `null`
        + `LinkedList` связный список (implementation `List` & `Deque`)
+ interface **`Map`** (нет итератора, нельзя перебирать в цикле. Можно получить представление в виде коллекции для перебора) 
`get()`, `put()`, `entrySet()`, `keySet()`, `values()`.
    + interface `SortedMap` (по порядку нарастания ключей)
    + interface `NavigableMap`
        + `TreeMap` реализация `Map` основанная на красно-чёрных деревьях (отсортированная по умолчанию `natural odering`, 
        можно задать свой компаратор)
    + `AbstractMap`
    + `HashMap` позволяет использовать `null` как в качестве ключа, так и значения
        + LinkedHashMap  это упорядоченная реализация хэш-таблицы. Аналогично `LinkedList`
    + `WeekHashMap` - реализация хэш-таблицы, которая организована с использованием weak references. 
Другими словами, `Garbage Collector` автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ 
этого элеметна нет жёстких ссылок

Справочник по Java Collections Framework https://habr.com/ru/post/237043/

[к оглавлению](#Collections-Lite)

## 19. Назовите основные методы интерфейса Collections?

Основные:
+ `int size()`
+ `boolean isEmpty()`
+ `boolean contains(Object o)`
+ `Iterator<E> iterator()`
+ `Object[] toArray()`
+ `boolean add(E e)`
+ `boolean remove(Object o)`
+ `void clear()`

Остальные:
+ `boolean containsAll(Collection<?> c)`
+ `boolean addAll(Collection<? extends E> c)`
+ `boolean removeAll(Collection<?> c)`
+ `boolean retainAll(Collection<?> c)`
+ `boolean equals(Object o)`
+ `int hashCode()`

[к оглавлению](#Collections-Lite)

## 20. Может ли null использоваться в качестве ключа в Map?

`HashMap` оперирует с `null`-ключом без каких-либо проблем. Его `hash` всегда равен `0`. 

В пустой `TreeMap` можно положить единственный `null`-ключ, 
все остальные операции (кроме `size()` и `clear()`, кстати) после этого не работают. 

В непустой `TreeMap` положить `null`-ключ нельзя из-за обязательного вызова `compareTo()`.

[к оглавлению](#Collections-Lite)

## 21. Может ли Set содержать null?

для `HashSet` работает. `TreeSet` — только для первого элемента.

[к оглавлению](#Collections-Lite)

## 22. Как преобразовать массив строк в ArrayList?

```java
Arrays.asList(words)
```

[к оглавлению](#Collections-Lite)

## 23. Как отсортировать список в обратном порядке?

```java
List reversedList = Collections.reverse(list)
```

[к оглавлению](#Collections-Lite)

## 24. Какие реализации SortedSet вы знаете и в чем их особенность?

`TreeSet` - в основе лежит красно-черное дерево, которое умеет само себя балансировать.

`TreeSet` все равно в каком порядке вы добавляете в него элементы, преимущества этой структуры данных будут сохраняться.

[к оглавлению](#Collections-Lite)

## 25. В каких случаях разумно использовать массив, а не ArrayList?

Рекомендация от Oracle: используйте `ArrayList` вместо массивов. 

Если ответить на этот вопрос нужно по-другому, то можно сказать следующее: 
Массивы могут быть быстрее и кушать меньше памяти. 
Списки теряют в производительности из-за возможности автоматического увеличения размера и сопутствующих проверок.

[к оглавлению](#Collections-Lite)

## 26. Какие коллекции синхронизированы?

Для этого используется пакет `Concurrent`. А также `@Deprecated` `HashTable`, `Vector`.

Получение синхронизированной коллекции из не синхронизированной:
```java
Collections.synchronizedList(list);
Collections.synchronizedSet(set);
Collections.synchronizedMap(map);
```

Получение коллекции только для чтения:
```java
Collections.unmodifiableList(list);
Collections.unmodifiableSet(set);
Collections.unmodifiableMap(map);
```

[к оглавлению](#Collections-Lite)

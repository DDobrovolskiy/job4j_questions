## FP Lambda Stream API

[1. Что такое lamdba выражение?](#1-Что-такое-lamdba-выражение)

[2. Что такое функциональные интерфейсы?](#2-Что-такое-функциональные-интерфейсы)

[3. Перечислите функциональные интерфейсы из пакета java.util.function?](#3-Перечислите-функциональные-интерфейсы-из-пакета-javautilfunction)

[4. Что такое функции высшего порядка?](#4-Что-такое-функции-высшего-порядка)

[5. Какие функциональные интерфейсы из пакета java.util.function поддерживают функции высшего порядка?](#5-Какие-функциональные-интерфейсы-из-пакета-javautilfunction-поддерживают-функции-высшего-порядка)

[6. Что такое ссылки на методы?](#6-Что-такое-ссылки-на-методы)

[7. Что такое ссылки на конструкторы?](#7-Что-такое-ссылки-на-конструкторы)

[8. Расскажите о зоне видимости переменных в lambda - выражениях?](#8-Расскажите-о-зоне-видимости-переменных-в-lambda-выражениях)

[9. Как быть в ситуации, если внутри lambda - выражении операторы могут выкинуть исключение?](#9-Как-быть-в-ситуации-если-внутри-lambda-выражении-операторы-могут-выкинуть-исключение)

[10. Что такое Stream API?](#10-Что-такое-Stream-API)

[11. Расскажите, какой шаблон проектирования используется внутри Stream API?](#11-Расскажите-какой-шаблон-проектирования-используется-внутри-Stream-API)

[12. Что делает метод filter?](#12-Что-делает-метод-filter)

[13. Что делает метод map.](#13-Что-делает-метод-map)

[14. Что делает метод flatMap?](#14-Что-делает-метод-flatMap)

[15. Что делает метод collect?](#15-Что-делает-метод-collect)

[16. Что делает метод reduce?](#16-Что-делает-метод-reduce)

[17. Что делает метод findFirst?](#17-Что-делает-метод-findFirst)

[18. Возможно ли прервать выполнение потока по аналогии с break?](#18-Возможно-ли-прервать-выполнение-потока-по-аналогии-с-break)

[19. Возможно ли пропустить элемент потока по аналогии с continue?](#19-Возможно-ли-пропустить-элемент-потока-по-аналогии-с-continue)

[20. Что такое Optional?](#20-Что-такое-Optional)

[21. Перечислите методы Optional?](#21-Перечислите-методы-Optional)

[22. Расскажите про фабричные методы List.of, Set.of, Map.of?](#22-Расскажите-про-фабричные-методы-Listof-Setof-Mapof)

[23. Для чего используется ключевое слово var?](#23-Для-чего-используется-ключевое-слово-var)

[24. В каких случаях можно использовать var?](#24-В-каких-случаях-можно-использовать-var)

[25. ](#25-)

## 1. Что такое lamdba выражение?

Лямбда-выражение представляет собой блок кода, который можно передать в другое место, поэтому он может быть выполнен 
позже один или несколько раз. По сути это функция, которая существует, но в данный момент времени не может быть вычислена.

По существу является анонимным (безымянным) методом, который реализует метод, определенный в функциональном интерфейсе.
```java
(входящие параметры через запятую без указания типа) -> {
    операторы;
    return вычисленное значение;
}
```
Если функция не принимает параметры, то указываем пустые скобки. Если не возвращает, то не указываем `return`.

подробнее https://www.ibm.com/developerworks/ru/library/j-java8lambdas/index.html

[к оглавлению](#FP-Lambda-Stream-API)

## 2. Что такое функциональные интерфейсы?

Функциональным называется интерфейс, который содержит только 1 абстрактный метод. 
Такой интерфейс описыват классическую математическую функцию.

Основное назначение – использование в лямбда выражениях, method reference или ссылок на конструкторы.
Функциональный интерфейс может содержать так же `default` и `static` методы.
К функциональному интерфейсу можно добавить аннотацию `@FunctionalInterface`

[к оглавлению](#FP-Lambda-Stream-API)

## 3. Перечислите функциональные интерфейсы из пакета javautilfunction?

В JDK в пакете java.util.function встроены готовые функциональные интерфейсы, описывающие всевозможные варианты.
Это `Consumer<T>`, `Function<T,R>`, `Predicate<T>`, `Supplier<T>`, `UnaryOperator<T>`, `BinaryOperator<T>` и их `Bi` – формы

+ **Predicate<T>** - проверяет соблюдение некоторого условия.
Если оно соблюдается, то возвращается значение `true`. В качестве параметра лямбда-выражение принимает объект типа `T`

+ **Function<T,R>** - представляет функцию перехода от объекта типа `T` к объекту типа `R`.

+ **Consumer<T>** - выполняет некоторое действие над объектом типа `T`, при этом ничего не возвращая.

+ **Supplier<T>** - принимает никаких аргументов, но должен возвращать объект типа `T`.

+ **BinaryOperator<T>** - принимает в качестве параметра два объекта типа `T`, выполняет над ними бинарную операцию
и возвращает ее результат также в виде объекта типа `T`.

+ **UnaryOperator<T>** - принимает в качестве параметра объект типа `T`,
выполняет над ними операции и возвращает результат операций в виде объекта типа `T`.

подробнее https://metanit.com/java/tutorial/9.3.php

[к оглавлению](#FP-Lambda-Stream-API)

## 4. Что такое функции высшего порядка?

Функции высшего порядка принимают другие функции в качестве своих параметров или возвращают 
другие функции в качестве своих результатов.

У языка Java — возможно, последнего среди популярных языков — наконец-то появились функции высшего порядка 
в форме так называемых лямбда-выражений.

Основная идея: функции имеют тот же статус, что и другие объекты данных.
```java
Function<Integer,Integer>   f = x -> x + 3;
BiFunction<Function<Integer,Integer>, Integer, Integer> g = (func, x) -> func.apply(x) * func.apply(x);
System.out.println(g.apply(f,7));
```

[к оглавлению](#FP-Lambda-Stream-API)

## 5. Какие функциональные интерфейсы из пакета javautilfunction поддерживают функции высшего порядка?

Также метод в Java может возвращать лямбда-выражение.

[к оглавлению](#FP-Lambda-Stream-API)

## 6. Что такое ссылки на методы?

Начиная с JDK 8 в Java можно в качестве параметра в метод передавать ссылку на другой метод.
В принципе данный способ аналогичен передаче в метод лямбда-выражения.

Ссылка на метод - это компактное лямбда-выражение, которое позволяет передавать ссылки на методы или конструкторы.

Ссылка на метод передается в виде:
+ `имя_класса::имя_статического_метода` ссылка на статический метод.

для нестатических методов:
+ `объект_класса::имя_метода` на метода конкретного объекта (экземпляра).
+ `тип_объекта::имя_метода` на метод произвольного объекта конкретного типа.
+ `название_класса::new` ссылка на конструктор.

Если существующий в классе метод уже делает все, что необходимо, то можно воспользоваться механизмом ссылки на метод
`method reference` для непосредственной передачи этого метода.

[к оглавлению](#FP-Lambda-Stream-API)

## 7. Что такое ссылки на конструкторы?

Можно в качестве параметров использовать конструкторы: `название_класса::new`, для дженериков `название_класса<T>::new`.

При использовании конструкторов методы функциональных интерфейсов должны принимать тот же список параметров,
что и конструкторы класса, и должны возвращать объект данного класса.

[к оглавлению](#FP-Lambda-Stream-API)

## 8. Расскажите о зоне видимости переменных в lambda выражениях?

Лямбда-выражения имеют доступ к переменным в области видимости, в которой их определили.
Но доступ возможен только при условии, что переменные являются `effective final`,
то есть либо явно имеют модификатор `final`, либо не меняют своего значения после инициализации (константы).
Если переменной присваивается значение во 2й раз, то лямбда-выражение вызовет ошибку компиляции.

Можно ссылаться на:
+ `effective final` локальные переменные;
+ поля примитивных типов;
+ статические переменные.

[к оглавлению](#FP-Lambda-Stream-API)

## 9. Как быть в ситуации, если внутри lambda выражении операторы могут выкинуть исключение?

Лямбда-выражение может генерировать исключение.
+ если тело лямбда-выражения может бросить проверяемое `checked` исключение, то оно должно быть объявлено в 
абстрактном методе целевого функционального интерфейса в выражении `throws`.
+ либо должно быть обработано внутри лямбда-выражения с помощью конструкции `try-catch-finally`.

Как известно из функциональных интерфейсов в `Stream API` нельзя выбрасывать контролируемые исключения.
Если по каким-то причинам это необходимо (например, работа с файлами, базами данных или по сети),
приходится оборачивать их в `RuntimeException`.

подробней https://www.codeflow.site/ru/article/java-lambda-exceptions

[к оглавлению](#FP-Lambda-Stream-API)

## 10. Что такое Stream API?

Начиная с JDK 8 в Java появился новый API - Stream API. Его задача - упростить работу с наборами данных, в частности, 
упростить операции фильтрации, сортировки и другие манипуляции с данными. 

Вся основная функциональность данного API сосредоточена в пакете `java.util.stream`. 
Ключевым понятием в Stream API является поток данных. 
Поток представляет канал передачи данных из источника данных.
Причем в качестве источника могут выступать как файлы, так и массивы и коллекции.

Все операции над потоками бывают 2х видов:
+ `terminal` терминальные или конечные операции возвращают конкретный результат (`void` или результат определенного типа).
+ `intermediate` промежуточные или конвейерные операции возвращают трансформированный поток.


Все потоки производят вычисления, в т.ч. в промежуточных операциях, только когда к ним применяется терминальная операция.
Т.е. в данном случае применяется отложенное выполнение.

Потоки не могут быть использованы повторно - как только была вызвана конечная операция, поток закрывается.

Одной из отличительных черт Stream API является применение лямбда-выражений, которые позволяют значительно
сократить запись выполняемых действий. Т.е. Stream API позволяет взаимодействовать с данными в функциональном стиле, 
пердставляя их в качестве конечного потока данных.

Javadoc https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html

Полное руководство по Java 8 Stream API в картинках и примерах https://annimon.com/article/2778

Шпаргалка Java программиста 4. Java Stream API https://habr.com/ru/company/luxoft/blog/270383/

[к оглавлению](#FP-Lambda-Stream-API)

## 11. Расскажите какой шаблон проектирования используется внутри Stream API?

шаблон Pipeline, опять же см. https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html

Для выполнения вычислений потоковые операции составляются в потоковый конвейер. 
Потоковый конвейер состоит из источника (который может быть массивом, коллекцией, функцией генератора, каналом ввода-вывода и т.д.), 
нуля или более промежуточных операций (которые преобразуют поток в другой поток, например `filter(Predicate)`), 
и терминальной операции (которая производит результат или побочный эффект, такой как `count()` или `forEach(Consumer)`). 
Потоки ленивы - вычисление исходных данных выполняется только тогда, когда инициируется работа терминала, а исходные 
элементы потребляются только по мере необходимости.

еще о паттерне pipeline от индуса https://medium.com/@deepakbapat/the-pipeline-design-pattern-in-java-831d9ce2fe21

[к оглавлению](#FP-Lambda-Stream-API)

## 12. Что делает метод filter?

`filter` промежуточная операция, используется для фильтрации через функцию.

Он принимает в качестве параметра некоторое условие в виде объекта `Predicate<T>`
и возвращает новый поток из элементов, которые удовлетворяют этому условию.

[к оглавлению](#FP-Lambda-Stream-API)

## 13. Что делает метод map?

`map` промежуточная операция. Отображение или маппинг позволяет задать функцию преобразования одного объекта в другой,
то есть получить из элемента одного типа элемент другого типа.

`<R> Stream<R> map(Function<? super T, ? extends R> mapper) `
Передаваемая в метод `map` функция задает преобразование от объектов типа `T` к типу `R`.
И в результате возвращается новый поток с преобразованными объектами.

[к оглавлению](#FP-Lambda-Stream-API)

## 14. Что делает метод flatMap?

`flatMap` промежуточная операция. Плоское отображение похоже на `map`, но может создавать из одного элемента несколько. 
Т.е. каждый объект будет преобразован в 0, 1 или несколько других объектов, поддерживаемых потоком. 

`<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)`

Например, мы хотим установить для каждого телефона цену со скидкой и цену без скидки.
Т.е. из одного объекта Phone нам надо получить два объекта с информацией в виде строки.
```java
    Stream<Phone> phoneStream = Stream.of(new Phone("iPhone 6 S", 54000), new Phone("Lumia 950", 45000),
                    new Phone("Samsung Galaxy S 6", 40000));
    phoneStream
        .flatMap(p->Stream.of(
                String.format("название: %s  цена без скидки: %d", p.getName(), p.getPrice()),
                String.format("название: %s  цена со скидкой: %d", p.getName(), p.getPrice() - (int)(p.getPrice()*0.1))
        ))
        .forEach(s->System.out.println(s));
```

[к оглавлению](#FP-Lambda-Stream-API)

## 15. Что делает метод collect?

`collect` терминальная операция, преобразует поток в коллекцию. 

Мы можем написать свою реализацию функции, однако Java уже предоставляет ряд встроенных функций, 
определенных в классе `Collectors`:
+ `toList()` преобразование к типу `List`
+ `toSet()` преобразование к типу `Set`
+ `toMap()` преобразование к типу `Map`

[к оглавлению](#FP-Lambda-Stream-API)

## 16. Что делает метод reduce?

`reduce` позволяет выполнять агрегатные функции на всей коллекцией и возвращать один результат.
Т.е. позволяет преобразовать все элементы стрима в один объект. Например, посчитать сумму всех элементов.
```java
    int sum = Stream.of(1,2,3,4,5).
        reduce(10, (acc, x) -> acc + x)); //10+1+2+3+4+5=25
```

Метод `reduce` выполняет терминальные операции сведения, возвращая некоторое значение - результат операции.
Он имеет следующие формы:
1. `Optional<T> reduce(BinaryOperator<T> accumulator)`
2. `T reduce(T identity, BinaryOperator<T> accumulator)`
3. `U reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner)`

Первая форма возвращает результат в виде объекта `Optional<T>`. Например, вычислим произведение набора чисел:

```java
    Stream<Integer> numbersStream = Stream.of(1,2,3,4,5,6);
    Optional<Integer> result = numbersStream.reduce((x,y)->x*y);
    System.out.println(result.get()); // 720
```

Объект `BinaryOperator<T>` представляет функцию, которая принимает два элемента и выполняет над ними некоторую операцию,
возвращая результат. При этом метод reduce сохраняет результат и затем опять же применяет к этому результату
и следующему элементу в наборе бинарную операцию.

Если нам надо, чтобы первым элементом в наборе было какое-то определенное значение, то мы можем использовать вторую
версию метода `reduce()`, которая в качестве первого параметра принимает `T identity`.
Этот параметр хранит значение, с которого будет начинаться цепочка бинарных операций. Например:

```java
    Stream<String> wordsStream = Stream.of("мама", "мыла", "раму");
    String sentence = wordsStream.reduce("Результат:", (x,y)->x + " " + y);
    System.out.println(sentence); // Результат: мама мыла раму
```

Допустим мы хотим найти сумму цен тех телефонов, у которых цена меньше определенного значения.
Для этого используем третью версию метода `reduce`:

```java
    Stream<Phone> phoneStream = Stream.of(new Phone("iPhone 6 S", 54000),
                new Phone("Lumia 950", 45000),
                new Phone("Samsung Galaxy S 6", 40000),
                new Phone("LG G 4", 32000));
    int sum = phoneStream.reduce(0,
                (x,y)-> {
                        if(y.getPrice()<50000)
                            return x + y.getPrice();
                        else
                            return x + 0;
                },
                (x, y)->x+y);
    System.out.println(sum); // 117000
```

[к оглавлению](#FP-Lambda-Stream-API)

## 17. Что делает метод findFirst?

`findFirst` терминальная операция, возвращает первый элемент из стрима в виде обертки `Optional`

[к оглавлению](#FP-Lambda-Stream-API)

## 18. Возможно ли прервать выполнение потока по аналогии с break?

Stream может выполнятся в несколько параллельных потоков, поэтому прерывание может привести к некорректным результатам.

С Java 9 можно использовать `java takeWhile` - промежуточная операция, возвращает элементы до тех пор, пока они
удовлетворяют условию, т.е. предикат возвращает `true`.

Лучше использовать итератор:
```java
    Iterator<BuyOrderType> iter = market.buyOrders() // replace BuyOrderType with correct type here
                .stream()
                .filter(buyOrder -> buyOrder.price >= sellOrder.price)
                .sorted(BY_ASCENDING_PRICE).iterator();
    while (iter.hasNext()) {
        BuyOrderType buyOrder = iter.next()  // replace BuyOrderType with correct type here
        double tradeVolume = Math.min(buyOrder.quantity, sellOrder.quantity);
        double price = buyOrder.price;
        buyOrder.quantity -= tradeVolume;
        sellOrder.quantity -= tradeVolume;
        Trade trade = new Trade.Builder(market, price, tradeVolume, Trade.Type.SELL).build();
        CommonUtil.convertToJSON(trade);
        if (sellOrder.quantity == 0) {
            System.out.println("order fulfilled");
            break;
        }
    }
```

[к оглавлению](#FP-Lambda-Stream-API)

## 19. Возможно ли пропустить элемент потока по аналогии с continue?

Вместо этого можно использовать `filter` - промежуточная операция, фильтрует элементы по условию.

А также `return`:
```java
    public static void main(String[] args) {
        ArrayList<String> stringList = new ArrayList<>();
        stringList.add("a");
        stringList.add("b");
        stringList.add("c");
        stringList.stream().forEach(str -> {
            if (str.equals("b")) return; // only skips this iteration.
            System.out.println(str); // a c
        });
    }
```

[к оглавлению](#FP-Lambda-Stream-API)

## 20. Что такое Optional?

В релизе Java 8 появился новый класс `Optional` призванный помочь разработчикам в обработке `NullPointerException`.

Опциональное значение `Optional` - это контейнер для объекта. Он может содержать значение или некоторый тип `<T>`, или
просто быть `null`.

Такая обертка является удобным средством предотвращения `NullPointerException`, т.к. имеет некоторые функции высшего 
порядка, избавляющие от добавления повторяющихся `if null/not null` проверок, что позволяет фокусироватья на 
выполнении непосредственной задачи.

```java
    //Пустой Optional объект
    Optional<Person> optionalPerson = Optional.empty();
    
    //Optional объект с ненулевым значением
    Optional<Person> optionalNonNull = Optional.of(somePerson);
    
    //Optional объект с возможностью нулевого значения
    Optional<Person> optionalNullable = Optional.ofNullable(somePerson);
```

Метод `ifPresent()` позволяет также устранить некоторую избыточность кода, следующего вида:
```java
     if(person != null) {
    	System.out.println(person);
     }
```
Те же действия, но с использованием `Optional`: `person.ifPresent(System.out::println);`

`orElse()`, `orElseThrow()`:

Как было раньше:`java Person personNew = person != null ? person : new Person();`

То же самое, но с использованием `Optional`: `java Person personNew = person.orElse(new Person());`

Или, если не хотим создавать объект, можно выбросить исключение:
`java Person personNewThrow = person.orElseThrow(Exception::new);`

[к оглавлению](#FP-Lambda-Stream-API)

## 21. Перечислите методы Optional?

+ `Optional.empty()` - возвращает `Optional` с `null` внутри.
+ `Optional.of(T value)` - возвращает `Optional` с `not null` значением внутри.
+ `Optional.ofNullable(T value)` - возвращает `Optional` который может содержать `null` значение внутри.

Методы конкретного объекта `Optional`:
+ `filter(Predicate<? super T> predicate)` - дает возможность отфильтровать значение опционального типа.
Мы передаем ему в параметр `Predicat` (это стандартный функциональный интерфейс), он возвращает булево значение. 
Если значение `true`, то возвращается этот же опционал, 
если значение `false`, то возвращается пустой опционал `Optional.empty()`.

+ `flatMap(Function<? super T,Optional<U>> mapper)` - применяется для изменения значения установленного в опционале. 
Функция которая передается в метод `flatMap` должна возвращать опционал. 
Если значение не установлено, вернется `Optional.empty()`.

+ `get()` - возвращает значение из объекта `Optional`. Нужно аккуратно использовать этот метод, т.к. он может бросить 
исключение `NoSuchElementException`, если значение в опционале равно `null`.
Чтобы безопасно использовать этот метод, перед его вызовом надо вызвать метод `isPresent()`.

+ `isPresent()` - возвращает булево значение `true`, если в опционале значение есть и возвращает `false`,
 если в опционале значение `null`.

+ `orElse(T other)` - используется для того, чтобы установить значение по-умолчанию в том случае,
если значение в опционале отсутствует.

+ `orElseGet(Supplier<? extends T> other)` - это аналог метода `orElse`,
только принимает в себя функциональный интерфейс, который должен вернуть значение.

+ `orElseThrow(Supplier<? extends X> exceptionSupplier)` - используется для того, чтобы бросить исключение,
которое передается в метод `orElseThrow`, если значения в опционале не установлено.

+ `ifPresent(Consumer<? super T> consumer)` - исполняет функциональный интерфейс `Consumer`, если значение в опционале 
присутствует. Т.е. в `ifPresent` передается фуекция, которая принимает один параметр - значение из `Optional`.

подробнее https://habr.com/ru/post/346782/

[к оглавлению](#FP-Lambda-Stream-API)

## 22. Расскажите про фабричные методы Listof Setof Mapof?

С приходом Java 9 создавать неизменяемые `immutable` коллекции `List`, `Set`, `Map` стало намного проще.
Фабричные методы позволяют преобразовывать элементы в потоки.

1. Создание списка `List<Integer> nums = List.of(1,2,3,4,5);`

    Метод `of()` в интерфейсе `List` перегружен и принимает от одного до десяти элементов. 
Если хотим создать коллекцию с более чем десятью элементами, тогда будет использоваться перегруженный метод с `varargs`:
`static <E> List<E> of(E... elements)`. Это сделано с целью оптимизации, т.к. при каждом вызове метода c `varargs` 
будет создаваться новый массив

2. Создание множества `Set<String> questions = Set.of("What?", "Where?", "When?");`

    Метод `of()` также имеет перегруженные методы, но в отличии от `List`, если передать дубликат в метод `of()`, то получим исключение
`Set<String> questions = Set.of("What?", "What?"); // IllegalArgumentException: duplicate element: What?`

3. Создание карты `Map<String, String> params = Map.of("Name:", "John", "Surname:", "Snow", "Status:", "Unmarried");`

    Последовательности идут парами `key`, `value`. Всего таких пар может быть 10, в отличии от `List` и `Set`,
если в последовательности будут повторения ключей - получим исключение
`Map.of("уникально", "наверняка", "уникально", "но это не точно"); // IllegalArgumentException: duplicate key: уникально`

Обратите внимание:
+ Вышеупомянутые коллекции нельзя изменить, при попытке получим `UnsupportedOperationException`.
+ В метод `of()` нельзя передать `null`, во всех коллекциях получим `NullPointerException`.
+ Метод `of()` не создает привычные `ArrayList`, `HashSet` или `HashMap`. В Java 9 были созданы специальные 
`ImmutableCollections` которые и возвращаются.
+ `ImmutableCollections` являются сериализуемыми, если содержимое тоже является сериализуемым.

[к оглавлению](#FP-Lambda-Stream-API)

## 23. Для чего используется ключевое слово var?

Нововведение Java 10 `var` аббревеатура `Local Variable Type-Inference`, 
используется для вывода типов локальных переменных.

Дает возможность сократить объявления переменных используя ключевое слово `var`.
При обработке `var`, компилятор просматривает правую часть объявления,
так называемый инициализатор и использует его тип для переменной.

`var` доступна только для локальных переменных с инициализатором. 
```java
     var first = 1;
     var second = 2;
     var rst = first + second;
     System.out.println(rst);
     
     var list = List.of(1, 2, 5);
     
     for(var item : items) {
        System.out.println(item);
     }
```

`var` это зарезервированное имя, но не ключевое слово (наряду с `true`, `false`, и `null`), что обеспечивает обратную 
совестимость программ, использующих его.

`var` нельзя использовать для:
+ полей класса;
+ параметров методов;
+ переменных без знания (т.е. без инициализатора).

также `var`:
+ не будет работать, если инициализируется `null`.
+ не будет работать для нелокальных переменных.
+ нельзя использовать в лямбда-выражениях, т.к. им нужен явный целевой тип.
+ нельзя использовать в случае инициализации массива.

[к оглавлению](#FP-Lambda-Stream-API)

## 24. В каких случаях можно использовать var?

`var` может использоваться только в сочетании с данными, т.е. нужно обязательно инициализировать переменную.
Компилятору нужно знать тип переменной, а тип можно извлечь только из значения.

[к оглавлению](#FP-Lambda-Stream-API)

## 25. ?



[к оглавлению](#FP-Lambda-Stream-API)

## Источники:

Изменения в языке Java 8 
https://www.ibm.com/developerworks/ru/library/j-java8lambdas/index.html

Встроенные функциональные интерфейсы
https://metanit.com/java/tutorial/9.3.php

Исключения в лямбда-выражениях Java 8
https://www.codeflow.site/ru/article/java-lambda-exceptions

Javadoc `Interface Stream<T>` 
https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html

Полное руководство по Java 8 Stream API в картинках и примерах 
https://annimon.com/article/2778

Шпаргалка Java программиста 4. Java Stream API 
https://habr.com/ru/company/luxoft/blog/270383/

паттерне pipeline 
https://medium.com/@deepakbapat/the-pipeline-design-pattern-in-java-831d9ce2fe21

Optional: Кот Шрёдингера в Java 8
https://habr.com/ru/post/346782/

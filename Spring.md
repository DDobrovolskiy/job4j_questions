### 1.Что такое Spring? Какие основные задачи выполняет этот фреймворк?
Обычно Spring описывают как облегченную платформу для построения Java-приложений, но с этим утверждением связаны два интересных момента. Во-первых, Spring можно использовать для построения любого приложения на языке Java (т.е. автономных, веб приложений, приложений JEE и т.д.), что отличает Spring от многих других платформ, таких как Apache Struts, которая ограничена только веб-приложениями. Во-вторых, характеристика “облегченная” в действительности не имеет никакого отношения к количеству классов или размеру дистрибутива; напротив, она определяет принцип всей философии Spring — минимальное воздействие. Платформа Spring является облегченной в том смысле, что для использования ядра Spring вы должны вносить минимальные (если вообще какие-либо) изменения в код своего приложения, а если в какой-то момент вы решите больше не пользоваться Spring, то и это сделать очень просто.   
Spring Framework, вероятно, наиболее известен как источник расширений (features), нужных для эффективной разработки сложных бизнес-приложений вне тяжеловесных программных моделей, которые исторически были доминирующими в промышленности. Ещё одно его достоинство в том, что он ввел ранее неиспользуемые функциональные возможности в сегодняшние господствующие методы разработки, даже вне платформы Java. Этот фреймворк предлагает последовательную модель и делает её применимой к большинству типов приложений, которые уже созданы на основе платформы Java. Считается, что Spring Framework реализует модель разработки, основанную на лучших стандартах индустрии, и делает её доступной во многих областях Java. Таким образом к достоинствам Spring можно отнести:

- Относительная легкость в изучении и применении фреймворка в разработке и поддержке приложения.
- Внедрение зависимостей (DI) и инверсия управления (IoC) позволяют писать независимые друг от друга компоненты, что дает преимущества в командной разработке, переносимости модулей и т.д..
- Spring IoC контейнер управляет жизненным циклом Spring Bean и настраивается наподобие JNDI lookup (поиска).
- Проект Spring содержит в себе множество подпроектов, которые затрагивают важные части создания софта, такие как вебсервисы, веб программирование, работа с базами данных, загрузка файлов, обработка ошибок и многое другое. Всё это настраивается в едином формате и упрощает поддержку приложения.

### 2. Что такое IoC и DI? В чем отличие этих терминов?
Принцип инверсии зависимостей — важный принцип объектно-ориентированного программирования, используемый для уменьшения зацепления в компьютерных программах. Входит в пятёрку принципов SOLID. Формулировка: Модули верхних уровней не должны импортировать сущности из модулей нижних уровней  
Инверсия управления — важный принцип объектно-ориентированного программирования, используемый для уменьшения зацепления в компьютерных программах. Также архитектурное решение интеграции, упрощающее расширение возможностей системы, при котором поток управления программы контролируется фреймворком.  

Внедрение зависимости (Dependency injection, DI) — процесс предоставления внешней зависимости программному компоненту. Является специфичной формой «инверсии управления» ( Inversion of control, IoC), когда она применяется к управлению зависимостями. В полном соответствии с принципом единой обязанности объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму. К достоинствам применения DI можно отнести:

- Сокращение объема связующего кода. Одним из самых больших плюсов DI является возможность значительного сокращения объема кода, который должен быть написан для связывания вместе различных компонентов приложения. Зачастую этот код очень прост — при создании зависимости должен создаваться новый экземпляр соответствующего объекта.
- Упрощенная конфигурация приложения. За счет применения DI процесс конфигурирования приложения значительно упрощается. Для конфигурирования классов, которые могут быть внедрены в другие классы, можно использовать аннотации или XML-файлы.
- Возможность управления общими зависимостями в единственном репозитории. При традиционном подходе к управлению зависимостями в общих службах, к которым относятся, например, подключение к источнику данных, транзакция, удаленные службы и т.п., вы создаете экземпляры (или получаете их из определенных фабричных классов) зависимостей там, где они нужны — внутри зависимого класса. Это приводит к распространению зависимостей по множеству классов в приложении, что может затруднить их изменение. В случае использования DI вся информация об общих зависимостях содержится в единственном репозитории (в Spring есть возможность хранить эту информацию в XML-файлах или Java классах), что существенно упрощает управление зависимостями и снижает количество возможных ошибок.
Улучшенная возможность тестирования. Когда классы проектируются для DI, становится возможной простая замена зависимостей. Это особенно полезно при тестировании приложения.
- Стимулирование качественных проектных решений для приложений. Вообще говоря, проектирование для DI означает проектирование с использованием интерфейсов. Используя Spring, вы получаете в свое распоряжение целый ряд средств DI и можете сосредоточиться на построении логики приложения, а не на поддерживающей DI платформе.

### 3. Перечислите основные модули Spring фреймворка.
 На данный момент среда Spring интегрировала более 20 модулей. Эти модули в основном делятся на основной контейнер, доступ к данным / интеграцию, Интернет, АОП (аспектно-ориентированное программирование), инструменты, сообщения и тестовые модули, как показано на рисунке ниже.  
![672c1bc4a455511ab886db063e93c3a6.png](https://russianblogs.com/images/494/672c1bc4a455511ab886db063e93c3a6.png)
### 4. Перечислите способы инъекций зависимостей.
 Реализация DI в Spring основана на двух ключевых концепциях Java — компонентах JavaBean и интерфейсах. При использовании Spring в качестве поставщика DI вы получаете гибкость определения конфигурации зависимостей внутри своих приложений разнообразными путями (т.е. внешне в XML-файлах, с помощью конфигурационных Java классов Spring или посредством аннотаций Java в коде). Компоненты JavaBean (также называемые POJO (Plain Old Java Object — простой старый объект Java)) предоставляют стандартный механизм для создания ресурсов Java, которые являются конфигурируемыми множеством способов. За счет применения DI объем кода, который необходим при проектировании приложения на основе интерфейсов, снижается почти до нуля. Кроме того, с помощью интерфейсов можно получить максимальную отдачу от DI, потому что бины могут использовать любую реализацию интерфейса для удовлетворения их зависимости.

К типам реализации внедрения зависимостей в Spring относят:

Constructor Dependency Injection — это тип внедрения зависимостей, при котором зависимости компонента предоставляются ему в его конструкторе (или конструкторах).

```java
public class ConstructorInjection {

private Dependency dependency;
  
  public ConstructorInjection(Dependency dependency) {
         this.dependency = dependency;
  }
}

public class ConstructorInjection {
 
private Dependency dependency;
  
  public ConstructorInjection(Dependency dependency) {
         this.dependency = dependency;
  }
}
```
Setter Dependency Injection – контейнер IoC внедряет зависимости компонента в компонент через методы установки в стиле JavaBean.

```java
public class SetterInjection {
private Dependency dependency;
   public void setDependency(Dependency dependency) {
           this.dependency = dependency;
   }
}

public class SetterInjection {
private Dependency dependency;
   public void setDependency(Dependency dependency) {
           this.dependency = dependency;
   }
}
```
### 5. Что такое ApplicationContext? Когда он создается?
Контекст (а у него есть даже интерфейс — ```java org.springframework.context.ApplicationContext ```) — это некоторое окружение, в котором работает приложение на Spring Framework. Страшные аббревиатуры DI, IoC — это всё про него. Собственно, контекст создаёт и хранит экземпляры классов вашего приложения, определяет их зависимости друг с другом и автоматически их задаёт.  
Безусловно, для того чтобы Spring создал контекст с экземплярами классов, ему нужно предоставить дополнительную информацию — мета-данные, из каких классов/объектов состоит ваше приложение, как они создаются, какие у них есть зависимости и т. д.
Они отличаются друг от друга именно тем, каким способом задаются мета-данные и где хранится эта конфигурация. Например:
— ```java ClassPathXmlApplicationContext ``` — метаданные конфигурируются XML-файлом(-ами) и они лежат в classpath, т. е. в ресурсах модуля;
— ```java FileSystemXmlApplicationContext ``` — метаданные тоже конфигурируются XML-файлом(-ами), но они находятся где-то в файловой системе, например, /etc/yourapp/spring-context.xml;
— ```java AnnotationConfigApplicationContext ``` — метаданные конфигурируются с помощью аннотаций прямо на классах.  
Это класс, который в основном представляет собой реестр всех бобов, загруженных spring. В общем случае запуск spring означает поиск загружаемых бобов и помещение их в контекст приложения (это относится только к синглетам, бобы областей прототипов не хранятся в ApplicationContext ).  

### 6. Расскажите, что такое Spring Bean? Опишите жизненный цикл Spring Bean?
Знакомство со Spring IoC начнем с главного термина: бин (англ. — bean). Самыми простыми словами,
> Бин — создаваемый Spring-ом объект класса, который можно внедрить в качестве значения поля в другой объект.

Хотите словами посложнее? А пожалуйста:
> Бин — объект класса, представляющий собой завершенный программный элемент с определенной бизнес-функцией либо внутренней функцией Spring'а, жизненным циклом которого управляет контейнер бинов.  

![303.jpg](https://itsobes.ru/assets/JavaSobes/303.jpg)  
следующие этапы проходит каждый отдельно взятый бин:

1. Инстанцирование объекта. Техническое начало жизни бина, работа конструктора его класса;

2. Установка свойств из конфигурации бина, внедрение зависимостей;

3. Нотификация aware-интерфейсов. BeanNameAware, BeanFactoryAware и другие. Мы уже писали о таких интерфейсах ранее. Технически, выполняется системными подтипами BeanPostProcessor, и совпадает с шагом 4;

4. Пре-инициализация – метод postProcessBeforeInitialization() интерфейса BeanPostProcessor;

5. Инициализация. Разные способы применяются в таком порядке:
• Метод бина с аннотацией @PostConstruct из стандарта JSR-250 (рекомендуемый способ);
• Метод afterPropertiesSet() бина под интерфейсом InitializingBean;
• Init-метод. Для отдельного бина его имя устанавливается в параметре определения initMethod. В xml-конфигурации можно установить для всех бинов сразу, с помощью default-init-method;

6. Пост-инициализация – метод postProcessAfterInitialization() интерфейса BeanPostProcessor.
Когда IoC-контейнер завершает свою работу, мы можем кастомизировать этап штатного уничтожения бина. Как со всеми способами финализации в Java, при жестком выключении (kill -9) гарантии вызова этого этапа нет. Три альтернативных способа «деинициализации» вызываются в том же порядке, что симметричные им методы инициализации:

1. Метод с аннотацией @PreDestroy;
2. Метод с именем, которое указано в свойстве destroyMethod определния бина (или в глобальном default-destroy-method);
3. Метод destroy() интерфейса DisposableBean.

Не следует путать жизненный цикл отдельного бина с жизненным циклом контекста и этапами подготовки фабрик бинов. О них мы поговорим в будущих публикациях.
### 7. Объясните для чего используются аннотации @Autowired @Qualifier. Когда, какой нужно использовать?
> @Autowired - используется для автоматического связывания зависимостей в spring beans. 
> @Qualifier - используется совместно с @Autowired для уточнения данных связывания, когда возможны коллизии (например одинаковых имен\типов).
### 8. Что такое FactoryBeans?
BeanFactory можно понимать как фабричный класс, содержащий коллекцию bean-компонентов. BeanFactory содержит определение типа bean-компонента, так что соответствующий bean-компонент может быть создан при получении клиентского запроса.  
BeanFactory также может создавать отношения между кооперативными классами при создании экземпляров объектов. Это освободит сам компонент и конфигурацию клиента компонента. BeanFactory также содержит управление жизненным циклом компонента, вызывая методы инициализации клиента (методы инициализации) и методы уничтожения (методы уничтожения).
### 9. Что такое Profiles? Когда их используют.
Активный профиль задается в файле application.properties:  
```java
spring.profiles.active=dev
```
Для каждого профиля создадим соотвествующий файл:  
```java
application-dev.properties
application-test.properties
application-prod.properties
```
Поскольку в application.properties стоит активация профиля dev, DataSource будет инициализироваться настройками файла application-dev.properties
Тестировочный профиль активируется с помощью аннотации @ActiveProfiles(«test»):  
```java
@ActiveProfiles("test")
@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
```
Допустим, нам нужно создавать определенный бин только для определенного профиля. Для этого можно аннотировать бин с помощью @Profile. Аннотация применима как к классу, так и к методу.  
Давайте аннотируем класс ExampleTestBean, экземпляр которого будет создаваться только при активном профиле test:  
```java
@Profile("test")
@Component
public class ExampleTestBean {
}
```
Обратите внимание, что в предыдущем примере мы взяли и напечатали текущий активный профиль:  
```java
for (final String profileName : environment.getActiveProfiles()) {
    System.out.println("Currently active profile - " + profileName);
}
```
### 10. Расскажите про модуль Spring AOP.
 Модуль AOP в Spring обеспечивает нас такими сущностями, как “перехватчики” (interceptors) для перехвата приложения в определённые моменты. Например, когда выполняется определённый метод, мы можем добавить какую-то функциональность (к примеру, сделать запись в лог-файл приложения) как до, так и после выполнения метода.  
```java
import org.aspectj.lang.annotation.*;

@Aspect
public class Logging {

    @Pointcut("execution(* net.proselyte.aop.*.*(..))")
    public void selectAllMethodsAvaliable() {

    }

    @Before("selectAllMethodsAvaliable()")
    public void beforeAdvice() {
        System.out.println("Now we are going to initiate developer's profile.");
    }

    @After("selectAllMethodsAvaliable()")
    public void afterAdvice() {
        System.out.println("Developer's profile has been initiated.");
    }

    @AfterReturning(pointcut = "selectAllMethodsAvaliable()", returning = "someValue")
    public void afterReturningAdvice(Object someValue) {
        System.out.println("Value: " + someValue.toString());
    }

    @AfterThrowing(pointcut = "selectAllMethodsAvaliable()", throwing = "e")
    public void inCaseOfExceptionThrowAdvice(ClassCastException e) {
        System.out.println("We have an exception here: " + e.toString());
    }

}
```
### 11. Объясните шаблон проектирование Proxy? Где он используется в Spring.
Proxy (Заместитель)  
Паттерн Proxy широко используется в AOP и remoting.  
Хороший пример использования Proxy — это org.springframework.aop.framework.ProxyFactoryBean.  
Эта фабрика создаёт AOP-прокси на основе Spring-бина.  
Прокси предоставляет заместителя для другого объекта, чтобы контролировать доступ к нему.
```java
public class Main {
	
	public static void main(String[] args) {
		// Create math proxy
		IMath p = new MathProxy();

		// Do the math
		System.out.println("4 + 2 = " + p.add(4, 2));
		System.out.println("4 - 2 = " + p.sub(4, 2));
		System.out.println("4 * 2 = " + p.mul(4, 2));
		System.out.println("4 / 2 = " + p.div(4, 2));
	}
}

/**
 * "Subject"
 */
public interface IMath {

	public double add(double x, double y);

	public double sub(double x, double y);

	public double mul(double x, double y);

	public double div(double x, double y);
}

/**
 * "Real Subject"
 */
public class Math implements IMath {

	public double add(double x, double y) {
		return x + y;
	}

	public double sub(double x, double y) {
		return x - y;
	}

	public double mul(double x, double y) {
		return x * y;
	}

	public double div(double x, double y) {
		return x / y;
	}
}

/**
 * "Proxy Object"
 */
public class MathProxy implements IMath {

    private Math math;

    public double add(double x, double y) {
        lazyInitMath();
        return math.add(x, y);
    }

    public double sub(double x, double y) {
        lazyInitMath();
        return math.sub(x, y);
    }

    public double mul(double x, double y) {
        lazyInitMath();
        return math.mul(x, y);
    }

    public double div(double x, double y) {
        lazyInitMath();
        return math.div(x, y);
    }

    private void lazyInitMath() {
        if (math == null) {
            math = new Math();
        }
    }
}
```
### 12. Объясните, как происходит интеграция с JDBC.
Spring предоставляет отличную поддержку JDBC API и предлагает класс утилиту JdbcTemplate, с помощью которого можно избавиться от многократного повторения похожего кода в приложении (вроде операций open \ closing connection; ResultSet, PreparedStatement и др.). Для подключения необходимо настроить файл конфигурации spring и получить объект JdbcTemplate.  
На данном этапы мы напишем все через JDBC. Spring напрямую не работает с базой. Он использует JDBC библиотеки.
Spring оборачивает JDBC в свои классы, делая их удобными для работы. Здесь используется шаблон "Декоратор".
```java
@Configuration
@PropertySource("classpath:app.properties")
@EnableTransactionManagement
public class JdbcConfig {

    @Bean
    public DataSource ds(@Value("${jdbc.driver}") String driver,
                         @Value("${jdbc.url}") String url,
                         @Value("${jdbc.username}") String username,
                         @Value("${jdbc.password}") String password) {
        BasicDataSource ds = new BasicDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(username);
        ds.setPassword(password);
        return ds;
    }

    @Bean
    public JdbcTemplate jdbc(DataSource ds) {
        return new JdbcTemplate(ds);
    }

}
```
 
### 13. Объясните, как происходит интеграция с Hibernate.
Для интеграции Hibernate в Spring необходимо подключить зависимости, а так же настроить файл конфигурации Spring. Т.к. настройки несколько отличаются между проектами и версиями, то смотрите официальную документацию Spring и Hibernate для уточнения настроек для конкретных технологий.
 
### 14. Что такое Transaction Manager? Где он используется? Когда он нужен?
 Фабрика может создавать объекты EntityManager, вызывая методы которого можно управлять сущностями. EntityManager, в отличие от фабрики, достаточно легковесен и поэтому зачастую создаётся по месту использования и в больших количествах. Если проводить аналогию с обычным JDBC, то EntityManagerFactory будет аналогом DataSource, а EntityManager аналогом Connection.

Каждый экземпляр EntityManager связан с экземпляром EntityTransaction, что позволяет управлять транзакциями:
```java
EntityManager em = entityManagerFactory.createEntityManager();
em.getTransaction().begin();
//Some actions
em.getTransaction().commit();
em.getTransaction().begin();
//Some actions
em.getTransaction().rollback();
```
Один или несколько EntityManager образуют или могут образовать persistence context. Я не буду переводить этот термин, попробую лучше его объяснить. Наличие persistence context означает, что для каждой существующей на данный момент сущности существует EntityManager, который следит за её состоянием.

> Transaction менеджер   

* Менеджер транзакций должен предоствить ответ на два вопроса:  

Должен ли создаться новый Entity Manager?  
Должна ли стартовать новая транзакция БД?  
Ответы необходимы предоставить в момент когда вызывается логика аспекта транзакций в момент «до».  Менеджер транзакций принимает решение, основываясь на следующих фактах:  

выполняется ли хоть одна транзакция в текущий момент ли нет  
атрибута «propagation» у метода, аннотированного @Transactional (для примера, REQUIRES_NEW всегда стартует новую транзакцию).  
Если менеджер решил создать новую транзакцию, тогда:  

Создается новый entity менеджер  
«Привязка» entity менеджера к текущему потоку (Thread)  
 «Взятие» соединения из пула соединений БД  
«Привязка» соединения к текущему потоку  
И entity менеджер и это соединение  привязываются к текущему потоку, используя  переменные ThreadLocal.  

Они хранятся в потоке, пока выполняется транзакция, и затем передаются менеджеру транзакций для очистки, когда они уже будут не нужны.  

Любая часть программы, которой нужен текущий entity manager или соединение, может заполучить их из потока. Этим компонентом программы, который делает именно так является Entity Manager Proxy.  

EntityManager proxy  
Прокси Entity менеджера (который был представлен ранее) это последний кусоче паззла. Когда бизнес метод делает вызов, например, entityManager.persist(), этот вызов не вызывается напрямую у entity менеджера.  

Вместо этого бизнес метод вызывает прокси, который достает текущий entity менеджер  из потока, в который его положил менеджер транзакций.  

Зная теперь все части механизма @Transactional, давайте пройдемся по обычной конфигурации Spring, необходимой для работы всего этого.  
### 15. Расскажите о модуле Spring MVC.
Фреймворк Spring MVC обеспечивает архитектуру паттерна Model — View — Controller (Модель — Отображение (далее — Вид) — Контроллер) при помощи слабо связанных готовых компонентов. Паттерн MVC разделяет аспекты приложения (логику ввода, бизнес-логику и логику UI), обеспечивая при этом свободную связь между ними.  

Model (Модель) инкапсулирует (объединяет) данные приложения, в целом они будут состоять из POJO («Старых добрых Java-объектов», или бинов).
View (Отображение, Вид) отвечает за отображение данных Модели, — как правило, генерируя HTML, которые мы видим в своём браузере.
Controller (Контроллер) обрабатывает запрос пользователя, создаёт соответствующую Модель и передаёт её для отображения в Вид.  

### 16. Объясните верхнеуровневую архитектуру Spring MVC: Dispatcher, ViewResolver.
 Вся логика работы Spring MVC построена вокруг DispatcherServlet, который принимает и обрабатывает все HTTP-запросы (из UI) и ответы на них. Рабочий процесс обработки запроса DispatcherServlet'ом проиллюстрирован на следующей диаграмме:
![2b09095f35224d0c96cc02d9fc471051.png]( https://hsto.org/r/w1560/web/2b0/909/5f3/2b09095f35224d0c96cc02d9fc471051.png)
Ниже приведена последовательность событий, соответствующая входящему HTTP-запросу:

После получения HTTP-запроса DispatcherServlet обращается к интерфейсу HandlerMapping, который определяет, какой Контроллер должен быть вызван, после чего, отправляет запрос в нужный Контроллер.
Контроллер принимает запрос и вызывает соответствующий служебный метод, основанный на GET или POST. Вызванный метод определяет данные Модели, основанные на определённой бизнес-логике и возвращает в DispatcherServlet имя Вида (View).
При помощи интерфейса ViewResolver DispatcherServlet определяет, какой Вид нужно использовать на основании полученного имени.
После того, как Вид (View) создан, DispatcherServlet отправляет данные Модели в виде атрибутов в Вид, который в конечном итоге отображается в браузере.

Все вышеупомянутые компоненты, а именно, HandlerMapping, Controller и ViewResolver, являются частями интерфейса WebApplicationContext extends ApplicationContext, с некоторыми дополнительными особенностями, необходимыми для создания web-приложений.

### 17. Как конфигурировать Spring MVC?
Вам будет необходимо связать (замапить) запросы, которые Вы хотите обработать при помощи DispatcherServlet, используя мапинг URL в файле web.xml
 
### 18. Что такое Spring scope? Какие типы Spring scope существуют?
В Spring предусмотрены различные области времени действия бинов:

* singleton – может быть создан только один экземпляр бина. Этот тип используется спрингом по умолчанию, если не указано другое. Следует осторожно использовать публичные свойства класса, т.к. они не будут потокобезопасными.
* prototype – создается новый экземпляр при каждом запросе.
* request –  аналогичен prototype, но название служит пояснением к использованию бина в веб приложении. Создается новый экземпляр при каждом HTTP request.
* session – новый бин создается в контейнере при каждой новой HTTP сессии.
* global-session: используется для создания глобальных бинов на уровне сессии для Portlet  приложений.
 
### 19. Расскажите про аннотации @RequestMapping, @PathVariable, @RequestBody, @RequestParam, @ModelAttribute, @ResponseBody, @SessionAttribute, @CookieValue.
* @RequestMapping
Сопоставление действий запроса, аннотация @RequestMapping для сопоставления URL-адресов / встреч со всем классом или конкретным методом обработчика  
Атрибуты:
>value: String [] тип, необязательный, используется для сопоставления фактического адреса запроса с методом  
>name: тип String, не требуется, укажите псевдоним для адреса сопоставления  
>метод: RequestMethod [], необязательно, укажите тип запроса, GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE  
>consumes: String [] type, необязательно, укажите тип содержимого отправленного запроса (Content-Type), например: application / json, text / html и т. д.  
>производит: Тип строки, не является обязательным, указывает тип возвращаемого содержимого и должен быть типом, содержащимся в заголовке запроса.  
>params: String [] тип, необязательный, используйте этот метод только тогда, когда указанный запрос должен содержать определенные значения.
>заголовки: Тип String [], необязательный, используйте этот метод только тогда, когда в указанном запросе есть указанный заголовок.  
>Путь: тип String [], не требуется, в среде сервлетов, только отображение uri  

/ @RequestParam
Используется для присвоения указанного параметра запроса формальному параметру в методе.  
Атрибуты:
>name: Тип строки, не требуется, указывает имя, привязанное к заголовку запроса.  
>значение: строковый тип, необязательно, псевдоним атрибута namme.  
>required: логический тип, необязательный, указывает, должен ли параметр быть привязан.  
>defaultValue: тип строки, необязательный, значение параметра по умолчанию.  

* @PathVariable
Атрибуты
>value: тип строки, не требуется; если он не указан, параметр с тем же именем будет привязан по умолчанию, что означает значение переменной в значении uri.  

* @RequestHeader
Сопоставьте данные заголовка запроса с параметрами метода обработки.  
Атрибуты:  
>name: строковый тип, необязательно, имя, привязанное к заголовку запроса.  
>значение: строковый тип, необязательно, псевдоним имени.  
>required: логический тип, необязательный, указывает, должен ли параметр быть привязан.  
>defaultValue: тип строки, необязательный, значение параметра по умолчанию.  

* @CookieValue
Сопоставьте информацию cookie в заголовке запроса с параметрами метода обработки.  
Атрибуты:  
>name: строковый тип, необязательно, имя, привязанное к заголовку запроса.  
>значение: тип строки, не требуется, псевдоним имени.  
>required: логический тип, необязательный, указывает, должен ли параметр быть привязан.  
>defaultValue: тип строки, необязательный, значение параметра по умолчанию.  

* @SessionAttributes
Позволяет нам выборочно указать, какие атрибуты в модели необходимо передать объекту HttpSession.    
Атрибуты:  
>names: String [] тип, необязательно, имя атрибута в модели, то есть имя, хранящееся в HttpSession.  
>значение: тип String [], не обязательно, псевдоним атрибута names.  
>типы: Class <?> [], необязательно, укажите, должны ли параметры быть привязаны.  
>можно объявить только в классе, но не в методе.  

### 20. Расскажите про модуль Spring Security?
 Проект Spring Security предоставляет широкие возможности для защиты приложения. Кроме стандартных настроек для аутентификации, авторизации и распределения ролей и маппинга доступных страниц, ссылок и т.п., предоставляет защиту от различных вариантов атак (например CSRF). Имеет множество различных настроек, но остается легким в использовании.
Самым фундаментальным объектом является SecurityContextHolder. В нем хранится информация о текущем контексте безопасности приложения, который включает в себя подробную информацию о пользователе (принципале), работающим с приложением. Spring Security использует объект Authentication, пользователя авторизованной сессии.  

### 21. Как конфигурировать Spring Security?
Итак, создадим класс SecurityConfig, который расширяет класс WebSecurityConfigurerAdapter. Сделаем его бином с помощью @EnableWebSecurity:
```java
@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    UserService userService;

    @Bean
    public BCryptPasswordEncoder bCryptPasswordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Override
    protected void configure(HttpSecurity httpSecurity) throws Exception {
        httpSecurity
                .csrf()
                    .disable()
                .authorizeRequests()
                    //Доступ только для не зарегистрированных пользователей
                    .antMatchers("/registration").not().fullyAuthenticated()
                    //Доступ только для пользователей с ролью Администратор
                    .antMatchers("/admin/**").hasRole("ADMIN")
                    .antMatchers("/news").hasRole("USER")
                    //Доступ разрешен всем пользователей
                    .antMatchers("/", "/resources/**").permitAll()
                //Все остальные страницы требуют аутентификации
                .anyRequest().authenticated()
                .and()
                    //Настройка для входа в систему
                    .formLogin()
                    .loginPage("/login")
                    //Перенарпавление на главную страницу после успешного входа
                    .defaultSuccessUrl("/")
                    .permitAll()
                .and()
                    .logout()
                    .permitAll()
                    .logoutSuccessUrl("/");
    }

    @Autowired
    protected void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
        
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth.jdbcAuthentication()
            .dataSource(ds)
            .withUser(User.withUsername("user")
                    .password(passwordEncoder().encode("123456"))
                    .roles("USER"));
}
    }
}
```
Аннотацию @EnableWebSecurity необходимо прописывать при настройке аутентификации, а иначе, как сказано в документации, поведение будет непредсказуемым. Хотя наш пример работает и просто с @Configuration.
 

Аутентификацию выполняет AuthenticationManager, но определять этот бин явно нам не надо. Вместо этого надо переопределить метод configure(AuthenticationManagerBuilder auth) класса WebSecurityConfigurerAdapter — так мы получим доступ к билдеру AuthenticationManagerBuilder, а уж через него настроим нужный нам AuthenticationManager.  Делается это так:

Во первых, в билдере надо задать тип аутентификации — она может быть не In-Memory, а другой: например, Jdbc, LDAP или кастомной  (тип аутинтификации задает где в принципе хранится пользователь). У нас In-Memory аутентификация — этот факт задается строкой auth.inMemoryAuthentication().
Далее идут специфические настройки выбранного AuthenticationManager. В них уточняется, как AuthenticationManager извлекает хранимого пользователя, чтоб потом сравнить его с введенным. В случае In-Memory аутентификации менеджеру далеко ходить не надо, реальные имя и пароль задаются тут же с помощью withUser() и password():
```java
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Bean
    public PasswordEncoder passwordEncoder() {
        return NoOpPasswordEncoder.getInstance();
    }
    @Override
    public void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
                .withUser("u1")
                   .password("p1")
                   .authorities("ROLE_USER")
                .and()
                .withUser("u2")
                   .password("p2")
                   .authorities("ROLE_USER");
    }
}
```
На самом деле AuthenticationManager достает не только реальные имя и пароль, но еще разрешение пользователя (что ему разрешено делать в приложении). Мы задали двух пользователей с разрешением ROLE_USER. В данном примере разрешения не используются, мы будем их использовать в примере про авторизацию.  

Итак, мы настроили AuthenticationManager, который сравнивает переданные имя и пароль со значениями имени и пароля u1 p1 и u2 p2. В случае совпадения с любым из пользователей, аутентификация проходит успешно.  

Обратите внимание на бин PasswordEncoder — в нем задается, как шифровать пароль. Мы задали NoOpPasswordEncoder, который не делает ничего — оставляет пароль в первоначальном виде. Это выбрано в учебных целях, чтобы было наглядно, что требуется вводить в форму логина при запуске примера — ведь в методе password(«p2») задается уже зашифрованный пароль. Конечно, в реальном приложении NoOpPasswordEncoder не пригоден — пароль нужно шифровать, например, с помощью BCryptPasswordEncoder.
 
### 22. Что такое UserDetails?
Пользователь» – это просто Object. В большинстве случаев он может быть
приведен к классу UserDetails. UserDetails можно представить, как адаптер между БД пользователей и тем что требуется Spring Security внутри SecurityContextHolder.
 
### 23.  Расскажите верхнеуровневую архитектуру Spring Security.
![6b1d6620a1c753b570a28126635bff8e.JPEG](https://russianblogs.com/images/142/6b1d6620a1c753b570a28126635bff8e.JPEG)
 Самый основной объектSecurityContextHolderЭто детали текущего контекста безопасности приложения, которые мы храним, в том числе сведения об основной части приложения, которое используется в настоящее время. Например, кто является действующим в настоящее время пользователем, прошел ли он проверку подлинности, и какие разрешения он имеет?

по умолчанию,SecurityContextHolderиспользованиеThreadLocalДля сохранения этих подробностей это означает, что контекст безопасности всегда можно использовать для методов в одном и том же потоке выполнения, даже если контекст безопасности явно не передается в качестве параметра этих методов.

Получить информацию о текущем пользователе

Поскольку информация об идентичности привязана к текущему потоку выполнения, вы можете использовать следующий блок кода для получения имени пользователя в настоящий момент прошедшего проверку подлинности пользователя в приложении:
```java
Object principal = SecurityContextHolder.getContext()
  .getAuthentication().getPrincipal();
 
if (principal instanceof UserDetails) {
  String username = ((UserDetails)principal).getUsername();
} else {
  String username = principal.toString();
}
```
перевод getContext()Возвращенный объектSecurityContextЭкземпляр интерфейса, соответствующийSecurityContextИнтерфейс определяется следующим образом:
```java
// org/springframework/security/core/context/SecurityContext.java
public interface SecurityContext extends Serializable {
    Authentication getAuthentication();
    void setAuthentication(Authentication authentication);
}
```
Authentication

В интерфейсе SecurityContext определены два абстрактных метода, getAuthentication и setAuthentication. Когда вызывается метод getAuthentication, возвращается объект типа Authentication. Здесь Authentication также является интерфейсом, который определяется следующим образом:
```java
// org/springframework/security/core/Authentication.java
public interface Authentication extends Principal, Serializable {
     // Список информации о разрешениях, по умолчанию используется некоторый класс реализации интерфейса GrantedAuthority, обычно ряд строк, представляющих информацию о разрешениях.
    Collection<? extends GrantedAuthority> getAuthorities();
     // Информация о пароле, строка пароля, введенная пользователем, обычно удаляется после аутентификации для обеспечения безопасности.
    Object getCredentials();
    Object getDetails();
     // Наиболее важная информация об идентичности в большинстве случаев возвращает класс реализации интерфейса UserDetails, который также является одним из часто используемых интерфейсов в платформе.
    Object getPrincipal();
    boolean isAuthenticated();
    void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;
}
```
Приведенный выше интерфейс аутентификации - это интерфейс в пакете JAR Spring-Security-Core, непосредственно унаследованный от класса Principal, а принципал находится в пакете java.security, который показывает, что Authentication является основным интерфейсом в Spring Security.Через класс реализации интерфейса аутентификации мы можем получить список информации о правах доступа, принадлежащей пользователю, пароль, данные пользователя, информацию об идентификации пользователя, информацию об аутентификации и т. Д.

2.2 Резюме

Давайте кратко суммируем отношения между тремя объектами SecurityContextHolder, SecurityContext и Authentication. SecurityContextHolder используется для сохранения SecurityContext (объекта контекста безопасности). Вызывая методы в объекте SecurityContext, такие как метод getAuthentication, мы можем легко получить объект Authentication Используя этот объект, мы можем получить подробную информацию о проверенных пользователях.
### 24. Что такое FilterChainProxy?
https://www.youtube.com/watch?v=D0ysdBq9z5w&ab_channel=javabegin
 
### 25. Расскажите о схеме работы пользователь-роль.
```java
@EnableGlobalMethodSecurity(prePostEnabled = true)
...
@PreAuthorize("hasAuthority('ADMIN')")
```
 
### 26. Расскажите о SpringContextHolder.
 выше
### 27. Расскажите об аспектах многопоточного окружения в Spring.
 
### 28. Расскажите о тестирование Spring приложений?
Spring Boot предоставляет аннотацию @SpringBootTest, которую можно использовать в качестве альтернативы стандартной аннотации spring-test @ContextConfiguration, когда вам нужны функции Spring Boot. Аннотация работает, создавая ApplicationContext, используемый в ваших тестах, через SpringApplication. В дополнение к @SpringBootTest также предусмотрен ряд других аннотаций для тестирования более специфических фрагментов приложения.  

Если вы используете JUnit 4, не забудьте также добавить @RunWith(SpringRunner.class) в ваш тест, иначе аннотации будут проигнорированы. Если вы используете JUnit 5, нет необходимости добавлять эквивалент @ExtendWith(SpringExtension.class) в качестве @SpringBootTest, а остальные @… аннотации теста уже аннотированы с ним.  

По умолчанию @SpringBootTest не запускает сервер. Вы можете использовать атрибут webEnvironment @SpringBootTest для дальнейшего уточнения того, как выполняются ваши тесты:  

* MOCK (по умолчанию): загружает веб ApplicationContext и предоставляет фиктивную веб-среду. Встроенные серверы не запускаются при использовании этой аннотации. Если веб-среда недоступна на вашем пути к классам, этот режим прозрачно возвращается к созданию обычного не веб ApplicationContext. Его можно использовать вместе с @AutoConfigureMockMvc или @AutoConfigureWebTestClient для тестового тестирования вашего веб-приложения.
* RANDOM_PORT: загружает WebServerApplicationContext и предоставляет реальную веб-среду. Встроенные серверы запускаются и прослушивают случайный порт.
* DEFINED_PORT: загружает WebServerApplicationContext и предоставляет реальную веб-среду. Встроенные серверы запускаются и прослушивают определенный порт (из вашего application.properties) или порт 8080 по умолчанию.
* NONE: загружает ApplicationContext с помощью SpringApplication, но не предоставляет какой-либо веб-среды (фиктивной или иной).  
Если ваш тест является @Transactional, он по умолчанию откатывает транзакцию в конце каждого метода тестирования. Однако, поскольку использование этого соглашения с RANDOM_PORT или DEFINED_PORT неявно обеспечивает реальную среду сервлета, HTTP-клиент и сервер работают в отдельных потоках и, таким образом, в отдельных транзакциях. Любая транзакция, инициированная на сервере, в этом случае не откатывается.  

@SpringBootTest с webEnvironment = WebEnvironment.RANDOM_PORT также запустит сервер управления на отдельном случайном порте, если ваше приложение использует другой порт для сервера управления.  

### 29. Расскажите о тестирование Spring MVС приложений.
 Сердцем Spring-test-mvc является класс MockMvc, который можно использовать для написания тестов для любого приложения, реализованного с помощью Spring MVC
### 30. Расскажите о мониторинге Spring приложений.
https://habr.com/ru/post/535816/
